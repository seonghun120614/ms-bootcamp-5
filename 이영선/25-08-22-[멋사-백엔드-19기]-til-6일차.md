목차

복습

복습

1\. 배열, index를 통해서 접근?

\- 가변길이 매개변수

2\. 2차원 배열, 

\- 배열 표시, 다차원 배열을 구별할 수 있음.

\- 생성 후에 사용가능.

\- 중첩 후(?)

3\. 메서드

\- 객체가 가진 기능\- 각자 객체가 가진 기능, 자바 세상에서 객체의 기능에 따라 , 기능 정의는 메소드임.

\- 문법, 접근 제한자, 메소드명, 리턴 타입, 매게변수, 매개변수 갯수, 

\- 메소드 오버로딩

4\. 객체지향

\- 자바는 객체지향이다.

\- 각각의 객체들이 자기 자신이 어떤 값을 갖고 어떻게 행동해야 한다는 사실을 알고 있음.

\- 그래서 자바에서는 객체가 가장 중요하다.

\- 객체를 정의하는 추상화 과정이 필요하다: 불필요한 것들을 버리고 필요한 것만 남기는 것.

\- 메시징 : 인자값을 넣어서....

\- 필드 : 변수, 멤버 변수, 

\- 자바는 객체가 추상화 됐고, 클래스 도면을 이용해서 만들고, new키워드를 이용해서 인스턴스화 해서 실제 건물이 만들어짐.

\- 클래스

\- static 키워드 : 메모리에 미리 올라가는 애, 인스턴스화 되지 않아도 미리 메모리에 올라간다.  이 필드는 하나만 생긴다.

우리가 만든 클래스의 인스턴스화 할때, 클래스에서 정의된 값들이 인스턴스화 될때 마다 메모리에 생성되지만,

static는 매번 만들어 지지 않고 처음에 딱 한번만 만들어주고 다른 인스턴스와 상관없이, 모든 클래스(인스턴스?)에서 공유가 된다. 

5\. 메소드

\- 실제 객체가 할 수 있는 기능을 정리 해 놓은 애

\- 형식

접근제한자 리턴타입 메소드명(매개변수){

}

\- 종류

매개변수와 리턴타입의 유무에 따라 다양한 형태가 있다

6\. 접근제한자

public : 모두 공개

default : 접근제한자를 사용하지 않았을때, package에 제한

protected : 같은 패키지, 상속

private : 비공개

7\. 생성자

\- 기본 생성자 : 프로그래머가 생성자를 만들어 놓지 않았을 경우, 컴파일러가 자동으로 만듦

Person p = new Person()

8\. 용어

식별자

자바 컴벤션

클래스는 대문자

패키지 필드 메소드는 소문자

카멜 표기법

인스턴스 : 실체를 만드는 것.

속성 : 행위

메소드 

\----------------------------------------------------------------------------------------------------------------------------

복습

1\. 배열, index를 통해서 접근?

\- 가변길이 매개변수

2\. 2차원 배열, 

\- 배열 표시, 다차원 배열을 구별할 수 있음.

\- 생성 후에 사용가능.

\- 중첩 후(?)

3\. 메서드

\- 객체가 가진 기능- 각자 객체가 가진 기능, 자바 세상에서 객체의 기능에 따라 , 기능 정의는 메소드임.

\- 문법, 접근 제한자, 메소드명, 리턴 타입, 매게변수, 매개변수 갯수, 

\- 메소드 오버로딩

4\. 객체지향

\- 자바는 객체지향이다.

\- 각각의 객체들이 자기 자신이 어떤 값을 갖고 어떻게 행동해야 한다는 사실을 알고 있음.

\- 그래서 자바에서는 객체가 가장 중요하다.

\- 객체를 정의하는 추상화 과정이 필요하다: 불필요한 것들을 버리고 필요한 것만 남기는 것.

\- 메시징 : 인자값을 넣어서....

\- 필드 : 변수, 멤버 변수, 

\- 자바는 객체가 추상화 됐고, 클래스 도면을 이용해서 만들고, new키워드를 이용해서 인스턴스화 해서 실제 건물이 만들어짐.

\- 클래스

\- static 키워드 : 메모리에 미리 올라가는 애, 인스턴스화 되지 않아도 미리 메모리에 올라간다. 이 필드는 하나만 생긴다.

우리가 만든 클래스의 인스턴스화 할때, 클래스에서 정의된 값들이 인스턴스화 될때 마다 메모리에 생성되지만,

static는 매번 만들어 지지 않고 처음에 딱 한번만 만들어주고 다른 인스턴스와 상관없이, 모든 클래스(인스턴스?)에서 공유가 된다. 

5\. 메소드

\- 실제 객체가 할 수 있는 기능을 정리 해 놓은 애

\- 형식

접근제한자 리턴타입 메소드명(매개변수){

}

\- 종류

매개변수와 리턴타입의 유무에 따라 다양한 형태가 있다

6\. 접근제한자

public : 모두 공개

default : 접근제한자를 사용하지 않았을때, package에 제한

protected : 같은 패키지, 상속

private : 비공개

7\. 생성자

\- 기본 생성자 : 프로그래머가 생성자를 만들어 놓지 않았을 경우, 컴파일러가 자동으로 만듦

Person p = new Person()

8\. 용어

식별자

자바 컴벤션

클래스는 대문자

패키지 필드 메소드는 소문자

카멜 표기법

인스턴스 : 실체를 만드는 것.

속성 : 행위

메소드 

\----------------------------------------------------------------------------------------------------------------------------

1.주사위 객체 추상화

-   예제 1

```
package day05;

import java.util.Random;
import java.util.Scanner;

public class Dice {
    //어떤 속성이 필요할까요?
    //속성 - 면, 눈
    int face=6;
     int eye;

    //기능 - 던지기, 굴리기
    public int roll() {
        Random rand = new Random();  //Java.util.Random
        eye = (int) (rand.nextInt(6)) + 1;
        //eye = (int)(Math.random()*face)+1;  //Math.random()은 0.1<=random<1.0, Java.lang
        return eye;
    }

    public void roll2(){
        int cnt=0; //몇 번 던질까에 카운팅.
        int cnt2=0; //최종 카운팅
        int diceCnt = 0; //숫자 카운팅
        int num = 0;  //카운팅할 숫자

        Scanner sc = new Scanner(System.in);
        System.out.print("몇 번 던질 까요? (0~100)");
        cnt2 = sc.nextInt();
        System.out.print("어떤 숫자를 카운팅 할까요?(1~6)");
        num = sc.nextInt();

        while(cnt++<cnt2){
            if(roll()==num)
                diceCnt++;
            System.out.print(eye + " ");
        }

        System.out.printf("\n" + num + "이 나온 횟수 : " + diceCnt);
    }
}
```

```
package day05;

import java.util.Scanner;

public class DiceExam {
    public static void main(String[] args) {
        Dice d1 = new Dice();

        d1.roll2();



    }
}
```

-   예제 2

```
package day05;

import java.util.Enumeration;
import java.util.Random;
import java.util.Scanner;

public class Dice {
    //어떤 속성이 필요할까요?
    //속성 - 면, 눈
    int face=6;
     int eye;

    //기능 - 던지기, 굴리기
    public int roll() {
        Random rand = new Random();  //Java.util.Random
        eye = (int) (rand.nextInt(6)) + 1;
        //eye = (int)(Math.random()*face)+1;  //Math.random()은 0.1<=random<1.0, Java.lang
        return eye;
    }

    public void countNum(int cnt2M, int numM){
        int cnt=0; //몇 번 던질까에 카운팅.
        int cnt2=cnt2M; //최종 카운팅
        int diceCnt = 0; //숫자 카운팅
        int num = numM;  //카운팅할 숫자

        while(cnt++<cnt2){
            if(roll()==num)
                diceCnt++;
            System.out.print(eye + " ");
        }

        System.out.printf("\n" + num + "이 나온 횟수 : " + diceCnt);
    }
}
```

```
package day05;

import java.util.Scanner;

public class DiceExam {
    public static void main(String[] args) {
        Dice d1 = new Dice();

        d1.roll();

        Scanner sc = new Scanner(System.in);
        System.out.print("몇 번 던질 까요? (0~100)");
        int cnt2 = sc.nextInt();
        System.out.print("어떤 숫자를 카운팅 할까요?(1~6)");
        int num = sc.nextInt();
        d1.countNum(cnt2, num);

    }
}
```
