목차

[객체추상화](#주사위-객체-추상화)

[생성자 오버로드](#생성자와-this)  

[import, 패키지(?) : 단일 import를 권장하고 있다.](#import,-패키지)







1.주사위 객체 추상화

-   예제 1

```
package day05;

import java.util.Random;
import java.util.Scanner;

public class Dice {
    //어떤 속성이 필요할까요?
    //속성 - 면, 눈
    int face=6;
     int eye;

    //기능 - 던지기, 굴리기
    public int roll() {
        Random rand = new Random();  //Java.util.Random
        eye = (int) (rand.nextInt(6)) + 1;
        //eye = (int)(Math.random()*face)+1;  //Math.random()은 0.1<=random<1.0, Java.lang
        return eye;
    }

    public void roll2(){
        int cnt=0; //몇 번 던질까에 카운팅.
        int cnt2=0; //최종 카운팅
        int diceCnt = 0; //숫자 카운팅
        int num = 0;  //카운팅할 숫자

        Scanner sc = new Scanner(System.in);
        System.out.print("몇 번 던질 까요? (0~100)");
        cnt2 = sc.nextInt();
        System.out.print("어떤 숫자를 카운팅 할까요?(1~6)");
        num = sc.nextInt();

        while(cnt++<cnt2){
            if(roll()==num)
                diceCnt++;
            System.out.print(eye + " ");
        }

        System.out.printf("\n" + num + "이 나온 횟수 : " + diceCnt);
    }
}
```

```
package day05;

import java.util.Scanner;

public class DiceExam {
    public static void main(String[] args) {
        Dice d1 = new Dice();

        d1.roll2();



    }
}
```

-   예제 2

```
package day05;

import java.util.Enumeration;
import java.util.Random;
import java.util.Scanner;

public class Dice {
    //어떤 속성이 필요할까요?
    //속성 - 면, 눈
    int face=6;
     int eye;

    //기능 - 던지기, 굴리기
    public int roll() {
        Random rand = new Random();  //Java.util.Random
        eye = (int) (rand.nextInt(6)) + 1;
        //eye = (int)(Math.random()*face)+1;  //Math.random()은 0.1<=random<1.0, Java.lang
        return eye;
    }

    public void countNum(int cnt2M, int numM){
        int cnt=0; //몇 번 던질까에 카운팅.
        int cnt2=cnt2M; //최종 카운팅
        int diceCnt = 0; //숫자 카운팅
        int num = numM;  //카운팅할 숫자

        while(cnt++<cnt2){
            if(roll()==num)
                diceCnt++;
            System.out.print(eye + " ");
        }

        System.out.printf("\n" + num + "이 나온 횟수 : " + diceCnt);
    }
}
```

```
package day05;

import java.util.Scanner;

public class DiceExam {
    public static void main(String[] args) {
        Dice d1 = new Dice();

        d1.roll();

        Scanner sc = new Scanner(System.in);
        System.out.print("몇 번 던질 까요? (0~100)");
        int cnt2 = sc.nextInt();
        System.out.print("어떤 숫자를 카운팅 할까요?(1~6)");
        int num = sc.nextInt();
        d1.countNum(cnt2, num);

    }
}
```

2\. 생성자와 this

-   기본 생성자

```
public class Book {
    String title;
    String author;
    int price;

    // 기본 생성자 (생략 가능)
    public Book() {
        System.out.println("Book 객체가 생성되었습니다.");
    }
}
```

-   생성자 오버로드

```
public class Book {
    String title;
    String author;
    int price;

    // 기본 생성자
    public Book() {
        this("제목없음", "작자미상", 0);
    }

    // 매개변수 1개
    public Book(String title) {
        this(title, "작자미상", 0);
    }

    // 매개변수 3개 (모든 필드 초기화)
    public Book(String title, String author, int price) {
        this.title = title;
        this.author = author;
        this.price = price;
    }

    public void displayInfo() {
        System.out.println("제목: " + title);
        System.out.println("저자: " + author);
        System.out.println("가격: " + price + "원");
        System.out.println("---");
    }
}
```

```
public class BookTest {
    public static void main(String[] args) {
        // 다양한 생성자 사용
        Book book1 = new Book();
        Book book2 = new Book("자바의 정석");
        Book book3 = new Book("이펙티브 자바", "조슈아 블로크", 36000);

        book1.displayInfo();
        book2.displayInfo();
        book3.displayInfo();
    }
}
```

-   this 키워드 

```
public class Person {
    private String name;
    private int age;
    private String address;

    // this를 사용한 필드 접근
    public Person(String name, int age) {
        this.name = name;  // this.name은 필드, name은 매개변수
        this.age = age;
    }

    // 메소드에서 this 사용
    public void introduce() {
        System.out.println("안녕하세요, 저는 " + this.name + "입니다.");
        System.out.println("나이는 " + this.age + "살입니다.");
    }

    // this를 반환하는 메소드 (메소드 체이닝)
    public Person setAddress(String address) {
        this.address = address;
        return this;  // 현재 객체를 반환
    }

    public Person setAge(int age) {
        this.age = age;
        return this;
    }

    // 다른 메소드 호출 시 this 사용 (선택적)
    public void displayAll() {
        this.introduce();  // this는 생략 가능
        System.out.println("주소: " + address);
    }
}

// 사용 예제
public class PersonTest {
    public static void main(String[] args) {
        Person person = new Person("김철수", 25);

        // 메소드 체이닝
        person.setAddress("서울시 강남구")
              .setAge(26);

        person.displayAll();
    }
}
```

## import, 패키지

다른 패키지에 있는 똑같은 이름의 클래스를 2개 쓸 수 있을까요?

같은 클래스라고 할때, 하나는 패키지 명을 풀로작성해서 써야 한다. 

kr.co.urmyheart.Scanner sc1 = new kr.co.urmyheart.Scanner(); 이렇게~~~~

[##_Image|kage@RSpRL/btsP13zApvr/AAAAAAAAAAAAAAAAAAAAAFOtaglp8W3VZ5AYwLp5qDibIEHoSE_SpRC1c_xo43th/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=ePhm95Hp05LVbjQ%2Bxusj4hteG0k%3D|CDM|1.3|{"originWidth":217,"originHeight":234,"style":"alignLeft","caption":"패키지 형태"}_##]

```
package day05;

import java.util.Scanner;
import kr.co.urmyheart.*;

public class Methodtest {
    public String mtest(){
        return "hello";
    }
    public static void main(String[] args) {
        Methodtest mt = new Methodtest();
        mt.mtest();

        System.out.println(mt.mtest().concat("test").toUpperCase());
        Scanner sc = new Scanner(System.in);
        kr.co.urmyheart.Scanner sc1 = new kr.co.urmyheart.Scanner();
        sc1.t1();

    }
}
```

```
package kr.co.urmyheart;

public class Scanner {
    public void t1() {
        System.out.println("testsss");
    }
}
```

static import

```
package day05;

import static java.lang.Math.*;

public class MathExample {
    public static void main(String[] args) {
        System.out.println(Math.PI);
        System.out.println(PI);
        System.out.println(sqrt(1.0));
        System.out.println(sin(1.0));
        System.out.println(sqrt(2));
    }
}
```

초보자초가 기억해야 할 메모리 개념

-   new 연산자를 사용할 때마다 메모리에 인스턴스가 생성된다.
-   인스턴스는 더 이상 참조되는 것이 없을 때, 나중에 가비지 컬렉션(Garbage Collection) 된다.
-   static한 필드는 클래스가 로딩될 때 딱 한번 메모리에 올라가고 초기화 된다.
-   인스턴스 메소드는 인스턴스를 생성하고나서 레퍼런스 변수를 이용해 사용할 수 있다.
-   클래스 메소드는 클래스명.메소드명() 으로 사용가능하다.
-   메소드 안에 선언된 변수들은 메소드가 실행될 때 메모리에 생성되었다가, 메소드가 종료될 때 사라진다.

패키지

static 필드와 메소드

```
package day05;

public class Student {
    // 인스턴스 필드
    String name;
    int score;

    // 클래스 필드 (모든 인스턴스가 공유)
    static int totalStudents = 0;
    static int totalScore = 0;

    // 생성자
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
        totalStudents++;
        totalScore += score;
    }

    // 인스턴스 메소드
    public void displayInfo() {
        System.out.println(name + ": " + score + "점");
    }

    // 클래스 메소드
    public static double getAverage() {
        if(totalStudents == 0) return 0;
        return (double)totalScore / totalStudents;
    }

    public static void displayStatistics() {
        System.out.println("전체 학생 수: " + totalStudents);
        System.out.println("전체 점수 합: " + totalScore);
        System.out.println("평균 점수: " + getAverage());
    }
}
```

```
package day05;

public class StudentTest {
    public static void main(String[] args) {
        // static 메소드는 객체 생성 없이 호출 가능
        Student.displayStatistics();
        System.out.println("---");

        Student s1 = new Student("김철수", 85);
        Student s2 = new Student("이영희", 92);
        Student s3 = new Student("박민수", 78);

        s1.displayInfo();
        s2.displayInfo();
        s3.displayInfo();
        System.out.println("---");

        // 클래스명으로 static 메소드 호출
        Student.displayStatistics();
    }
}
```
