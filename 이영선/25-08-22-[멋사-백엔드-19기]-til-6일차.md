목차

[복습](#복습)
[객체추상화](#
[생성자 오버로드 ]
[상속]
[메세지체이닝]
[import, 패키지(?) : 단일 import를 권장하고 있다.]





##복습

1\. 배열, index를 통해서 접근?

\- 가변길이 매개변수

2\. 2차원 배열, 

\- 배열 표시, 다차원 배열을 구별할 수 있음.

\- 생성 후에 사용가능.

\- 중첩 후(?)

3\. 메서드

\- 객체가 가진 기능\- 각자 객체가 가진 기능, 자바 세상에서 객체의 기능에 따라 , 기능 정의는 메소드임.

\- 문법, 접근 제한자, 메소드명, 리턴 타입, 매게변수, 매개변수 갯수, 

\- 메소드 오버로딩

4\. 객체지향

\- 자바는 객체지향이다.

\- 각각의 객체들이 자기 자신이 어떤 값을 갖고 어떻게 행동해야 한다는 사실을 알고 있음.

\- 그래서 자바에서는 객체가 가장 중요하다.

\- 객체를 정의하는 추상화 과정이 필요하다: 불필요한 것들을 버리고 필요한 것만 남기는 것.

\- 메시징 : 인자값을 넣어서....

\- 필드 : 변수, 멤버 변수, 

\- 자바는 객체가 추상화 됐고, 클래스 도면을 이용해서 만들고, new키워드를 이용해서 인스턴스화 해서 실제 건물이 만들어짐.

\- 클래스

\- static 키워드 : 메모리에 미리 올라가는 애, 인스턴스화 되지 않아도 미리 메모리에 올라간다.  이 필드는 하나만 생긴다.

우리가 만든 클래스의 인스턴스화 할때, 클래스에서 정의된 값들이 인스턴스화 될때 마다 메모리에 생성되지만,

static는 매번 만들어 지지 않고 처음에 딱 한번만 만들어주고 다른 인스턴스와 상관없이, 모든 클래스(인스턴스?)에서 공유가 된다. 

5\. 메소드

\- 실제 객체가 할 수 있는 기능을 정리 해 놓은 애

\- 형식

접근제한자 리턴타입 메소드명(매개변수){

}

\- 종류

매개변수와 리턴타입의 유무에 따라 다양한 형태가 있다

6\. 접근제한자

public : 모두 공개

default : 접근제한자를 사용하지 않았을때, package에 제한

protected : 같은 패키지, 상속

private : 비공개

7\. 생성자

\- 기본 생성자 : 프로그래머가 생성자를 만들어 놓지 않았을 경우, 컴파일러가 자동으로 만듦

Person p = new Person()

8\. 용어

식별자

자바 컴벤션

클래스는 대문자

패키지 필드 메소드는 소문자

카멜 표기법

인스턴스 : 실체를 만드는 것.

속성 : 행위

메소드 

\----------------------------------------------------------------------------------------------------------------------------



1.주사위 객체 추상화

-   예제 1

```
package day05;

import java.util.Random;
import java.util.Scanner;

public class Dice {
    //어떤 속성이 필요할까요?
    //속성 - 면, 눈
    int face=6;
     int eye;

    //기능 - 던지기, 굴리기
    public int roll() {
        Random rand = new Random();  //Java.util.Random
        eye = (int) (rand.nextInt(6)) + 1;
        //eye = (int)(Math.random()*face)+1;  //Math.random()은 0.1<=random<1.0, Java.lang
        return eye;
    }

    public void roll2(){
        int cnt=0; //몇 번 던질까에 카운팅.
        int cnt2=0; //최종 카운팅
        int diceCnt = 0; //숫자 카운팅
        int num = 0;  //카운팅할 숫자

        Scanner sc = new Scanner(System.in);
        System.out.print("몇 번 던질 까요? (0~100)");
        cnt2 = sc.nextInt();
        System.out.print("어떤 숫자를 카운팅 할까요?(1~6)");
        num = sc.nextInt();

        while(cnt++<cnt2){
            if(roll()==num)
                diceCnt++;
            System.out.print(eye + " ");
        }

        System.out.printf("\n" + num + "이 나온 횟수 : " + diceCnt);
    }
}
```

```
package day05;

import java.util.Scanner;

public class DiceExam {
    public static void main(String[] args) {
        Dice d1 = new Dice();

        d1.roll2();



    }
}
```

-   예제 2

```
package day05;

import java.util.Enumeration;
import java.util.Random;
import java.util.Scanner;

public class Dice {
    //어떤 속성이 필요할까요?
    //속성 - 면, 눈
    int face=6;
     int eye;

    //기능 - 던지기, 굴리기
    public int roll() {
        Random rand = new Random();  //Java.util.Random
        eye = (int) (rand.nextInt(6)) + 1;
        //eye = (int)(Math.random()*face)+1;  //Math.random()은 0.1<=random<1.0, Java.lang
        return eye;
    }

    public void countNum(int cnt2M, int numM){
        int cnt=0; //몇 번 던질까에 카운팅.
        int cnt2=cnt2M; //최종 카운팅
        int diceCnt = 0; //숫자 카운팅
        int num = numM;  //카운팅할 숫자

        while(cnt++<cnt2){
            if(roll()==num)
                diceCnt++;
            System.out.print(eye + " ");
        }

        System.out.printf("\n" + num + "이 나온 횟수 : " + diceCnt);
    }
}
```

```
package day05;

import java.util.Scanner;

public class DiceExam {
    public static void main(String[] args) {
        Dice d1 = new Dice();

        d1.roll();

        Scanner sc = new Scanner(System.in);
        System.out.print("몇 번 던질 까요? (0~100)");
        int cnt2 = sc.nextInt();
        System.out.print("어떤 숫자를 카운팅 할까요?(1~6)");
        int num = sc.nextInt();
        d1.countNum(cnt2, num);

    }
}
```

2\. 생성자와 this

-   기본 생성자

```
public class Book {
    String title;
    String author;
    int price;

    // 기본 생성자 (생략 가능)
    public Book() {
        System.out.println("Book 객체가 생성되었습니다.");
    }
}
```

-   생성자 오버로드

```
public class Book {
    String title;
    String author;
    int price;

    // 기본 생성자
    public Book() {
        this("제목없음", "작자미상", 0);
    }

    // 매개변수 1개
    public Book(String title) {
        this(title, "작자미상", 0);
    }

    // 매개변수 3개 (모든 필드 초기화)
    public Book(String title, String author, int price) {
        this.title = title;
        this.author = author;
        this.price = price;
    }

    public void displayInfo() {
        System.out.println("제목: " + title);
        System.out.println("저자: " + author);
        System.out.println("가격: " + price + "원");
        System.out.println("---");
    }
}
```

```
public class BookTest {
    public static void main(String[] args) {
        // 다양한 생성자 사용
        Book book1 = new Book();
        Book book2 = new Book("자바의 정석");
        Book book3 = new Book("이펙티브 자바", "조슈아 블로크", 36000);

        book1.displayInfo();
        book2.displayInfo();
        book3.displayInfo();
    }
}
```

-   this 키워드 

```
public class Person {
    private String name;
    private int age;
    private String address;

    // this를 사용한 필드 접근
    public Person(String name, int age) {
        this.name = name;  // this.name은 필드, name은 매개변수
        this.age = age;
    }

    // 메소드에서 this 사용
    public void introduce() {
        System.out.println("안녕하세요, 저는 " + this.name + "입니다.");
        System.out.println("나이는 " + this.age + "살입니다.");
    }

    // this를 반환하는 메소드 (메소드 체이닝)
    public Person setAddress(String address) {
        this.address = address;
        return this;  // 현재 객체를 반환
    }

    public Person setAge(int age) {
        this.age = age;
        return this;
    }

    // 다른 메소드 호출 시 this 사용 (선택적)
    public void displayAll() {
        this.introduce();  // this는 생략 가능
        System.out.println("주소: " + address);
    }
}

// 사용 예제
public class PersonTest {
    public static void main(String[] args) {
        Person person = new Person("김철수", 25);

        // 메소드 체이닝
        person.setAddress("서울시 강남구")
              .setAge(26);

        person.displayAll();
    }
}
```

## 3\. import, 패키지

다른 패키지에 있는 똑같은 이름의 클래스를 2개 쓸 수 있을까요?

같은 클래스라고 할때, 하나는 패키지 명을 풀로작성해서 써야 한다. 

kr.co.urmyheart.Scanner sc1 = new kr.co.urmyheart.Scanner(); 이렇게~~~~

[##_Image|kage@RSpRL/btsP13zApvr/AAAAAAAAAAAAAAAAAAAAAFOtaglp8W3VZ5AYwLp5qDibIEHoSE_SpRC1c_xo43th/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=ePhm95Hp05LVbjQ%2Bxusj4hteG0k%3D|CDM|1.3|{"originWidth":217,"originHeight":234,"style":"alignLeft","caption":"패키지 형태"}_##]

```
package day05;

import java.util.Scanner;
import kr.co.urmyheart.*;

public class Methodtest {
    public String mtest(){
        return "hello";
    }
    public static void main(String[] args) {
        Methodtest mt = new Methodtest();
        mt.mtest();

        System.out.println(mt.mtest().concat("test").toUpperCase());
        Scanner sc = new Scanner(System.in);
        kr.co.urmyheart.Scanner sc1 = new kr.co.urmyheart.Scanner();
        sc1.t1();

    }
}
```

```
package kr.co.urmyheart;

public class Scanner {
    public void t1() {
        System.out.println("testsss");
    }
}
```

static import

```
package day05;

import static java.lang.Math.*;

public class MathExample {
    public static void main(String[] args) {
        System.out.println(Math.PI);
        System.out.println(PI);
        System.out.println(sqrt(1.0));
        System.out.println(sin(1.0));
        System.out.println(sqrt(2));
    }
}
```

초보자초가 기억해야 할 메모리 개념

-   new 연산자를 사용할 때마다 메모리에 인스턴스가 생성된다.
-   인스턴스는 더 이상 참조되는 것이 없을 때, 나중에 가비지 컬렉션(Garbage Collection) 된다.
-   static한 필드는 클래스가 로딩될 때 딱 한번 메모리에 올라가고 초기화 된다.
-   인스턴스 메소드는 인스턴스를 생성하고나서 레퍼런스 변수를 이용해 사용할 수 있다.
-   클래스 메소드는 클래스명.메소드명() 으로 사용가능하다.
-   메소드 안에 선언된 변수들은 메소드가 실행될 때 메모리에 생성되었다가, 메소드가 종료될 때 사라진다.

패키지

static 필드와 메소드

```
package day05;

public class Student {
    // 인스턴스 필드
    String name;
    int score;

    // 클래스 필드 (모든 인스턴스가 공유)
    static int totalStudents = 0;
    static int totalScore = 0;

    // 생성자
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
        totalStudents++;
        totalScore += score;
    }

    // 인스턴스 메소드
    public void displayInfo() {
        System.out.println(name + ": " + score + "점");
    }

    // 클래스 메소드
    public static double getAverage() {
        if(totalStudents == 0) return 0;
        return (double)totalScore / totalStudents;
    }

    public static void displayStatistics() {
        System.out.println("전체 학생 수: " + totalStudents);
        System.out.println("전체 점수 합: " + totalScore);
        System.out.println("평균 점수: " + getAverage());
    }
}
```

```
package day05;

public class StudentTest {
    public static void main(String[] args) {
        // static 메소드는 객체 생성 없이 호출 가능
        Student.displayStatistics();
        System.out.println("---");

        Student s1 = new Student("김철수", 85);
        Student s2 = new Student("이영희", 92);
        Student s3 = new Student("박민수", 78);

        s1.displayInfo();
        s2.displayInfo();
        s3.displayInfo();
        System.out.println("---");

        // 클래스명으로 static 메소드 호출
        Student.displayStatistics();
    }
}
```
