목차

[클래스, 필드, 메소드 생성\](# 클래스,-필드,-메소드-생성) 

[클래스 객체생성, 필드와 메소드 호출\](## 클래스-객체생성,-필드와-메소드-호출)

[static 필드와 메소드\](# static-필드와-메소드)

## 클래스, 필드, 메소드 생성

```
package day04;

public class Pen {

        String 색깔;
        double 굵기;

        //생성자 - 클래스에 생성자가 하나도 정의되지 않으면
        //컴파일러가 자동으로 생성자를 만듦.

        //생성자 
        public Pen(){
            System.out.println("Pen() 생성자 실행");
        }


        //행위
        public static void 쓰다(String msg){
            System.out.println(msg);
            //return;
            System.out.println("돼");
        }

}
```

## 클래스 객체생성, 필드와 메소드 호출

```
package day04;

public class Pen_main {
    public static void main(String[] args) {
        //new Pen();
        Pen 볼펜 = new Pen();
        볼펜.색깔="검정";
        볼펜.굵기 =0.5;
        볼펜.쓰다("안녕?");


    }
}
```

## static 필드와 메소드, 접근제한자 public, package, protected, private

```
package day04;

public class Person {
    public String name; //전체 공개
    int age; //접근 제한자가 없으면 같은 패키지에서만 접근 공개
    protected String address="서울시"; //같은 패키지 상송된
    private String phoneNumber;


    static int count = 0; //클래스 필드
    static final int MAX_AGE = 150;

}
```

static

```
public class PersonExam {
    public static void main(String[] args) {
        //Persion 가진 필드를 이용하면 뭐해야하나요?

        Person p1 = new Person();

        Person.count++;

        Person kang = new Person();
        kang.name = "강경미";

        Person kim = new Person();
        kang.name = "김주원";

        kang.count++;
        System.out.println(kang.count);
        System.out.println(kim.count);

    }
}
```

public, default, private

```
package day04;

public class PersionExam2 {
    public static void main(String[] args) {
        Person person = new Person();

        person.name = "kang";
        person.age = 18;
        person.address = "경기도";
        //person.phoneNumber 안됨.
        System.out.println(Person.MAX_AGE);
        System.out.println(Person.count);
    }
}
```

protected

```
package day03;

import day04.Person;

public class PersionExam2 extends Person {
    public void test(){
        System.out.println(address);
    }

    public static void main(String[] args) {
        PersionExam2 p2 = new PersionExam2();
        p2.address= "경기도";


    }
}
```





------------------------------------------------------------------------------------------------------------8/22정리 내용
복습

1\. 배열, index를 통해서 접근?

\- 가변길이 매개변수

2\. 2차원 배열, 

\- 배열 표시, 다차원 배열을 구별할 수 있음.

\- 생성 후에 사용가능.

\- 중첩 후(?)

3\. 메서드

\- 객체가 가진 기능- 각자 객체가 가진 기능, 자바 세상에서 객체의 기능에 따라 , 기능 정의는 메소드임.

\- 문법, 접근 제한자, 메소드명, 리턴 타입, 매게변수, 매개변수 갯수, 

\- 메소드 오버로딩

4\. 객체지향

\- 자바는 객체지향이다.

\- 각각의 객체들이 자기 자신이 어떤 값을 갖고 어떻게 행동해야 한다는 사실을 알고 있음.

\- 그래서 자바에서는 객체가 가장 중요하다.

\- 객체를 정의하는 추상화 과정이 필요하다: 불필요한 것들을 버리고 필요한 것만 남기는 것.

\- 메시징 : 인자값을 넣어서....

\- 필드 : 변수, 멤버 변수, 

\- 자바는 객체가 추상화 됐고, 클래스 도면을 이용해서 만들고, new키워드를 이용해서 인스턴스화 해서 실제 건물이 만들어짐.

\- 클래스

\- static 키워드 : 메모리에 미리 올라가는 애, 인스턴스화 되지 않아도 미리 메모리에 올라간다. 이 필드는 하나만 생긴다.

우리가 만든 클래스의 인스턴스화 할때, 클래스에서 정의된 값들이 인스턴스화 될때 마다 메모리에 생성되지만,

static는 매번 만들어 지지 않고 처음에 딱 한번만 만들어주고 다른 인스턴스와 상관없이, 모든 클래스(인스턴스?)에서 공유가 된다. 

5\. 메소드

\- 실제 객체가 할 수 있는 기능을 정리 해 놓은 애

\- 형식

접근제한자 리턴타입 메소드명(매개변수){

}

\- 종류

매개변수와 리턴타입의 유무에 따라 다양한 형태가 있다

6\. 접근제한자

public : 모두 공개

default : 접근제한자를 사용하지 않았을때, package에 제한

protected : 같은 패키지, 상속

private : 비공개

7\. 생성자

\- 기본 생성자 : 프로그래머가 생성자를 만들어 놓지 않았을 경우, 컴파일러가 자동으로 만듦

Person p = new Person()

8\. 용어

식별자

자바 컴벤션

클래스는 대문자

패키지 필드 메소드는 소문자

카멜 표기법

인스턴스 : 실체를 만드는 것.

속성 : 행위

메소드 

\----------------------------------------------------------------------------------------------------------------------------
