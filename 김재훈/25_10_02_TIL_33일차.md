# UDP 통신

## UDP의 특징

- User Datagram Protocol
- 인터넷 상에서 데이터를 전송하기 위한 다른 방식의 프로토콜
- TCP와 달리 연결이 없는 프로토콜로, 데이터 전송 시 연결 과정이 없다.
- **특징**
    1. **비연결성**: 연결을 설정하지 않고, 데이터를 보내는 측에서 받는 측으로 직접 데이터를 전송한다.
    2. **속도**: 연결 설정이 없기 때문에, TCP보다 전송 속도가 빠르다.
    3. **비신뢰성**: 데이터의 도착을 보장하지 않으며, 데이터가 손상되거나 순서가 바뀌어 도착할 수 있다.

## UDP 작동 방식

- 데이터는 ‘데이터그램’이라는 작은 패킷으로 전송된다.
- 각 데이터그램은 독립적으로 처리되며, 이전의 데이터그램과의 연관성이 없다.
- 송신자는 데이터그램을 네트워크에 보내고, 수신자는 도착하는 데이터그램을 수집한다.

## UDP와 자바

- `java.net` 패키지의 `DatagramSocket`과 `DatagramPacket` 클래스를 사용하여 UDP 통신을 구현한다.
- **사용 사례**
    - 실시간성이 중요하고, 데이터의 손실이나 순서 바뀜이 크게 문제되지 않는 응용 프로그램에 적합하다.
    - 예를 들어, 실시간 비디오 스트리밍, 온라인 게임, VoIP(음성 통신) 등이 있다.

# UDP Echo 프로그래밍

## UDP Echo 개요

- 클라이언트가 서버에 메시지를 보내면, 서버가 동일한 메시지를 클라이언트에게 되돌려주는 간단한 네트워크 애플리케이션이다.
- TCP와 달리 UDP는 연결이 없는 통신을 사용하므로, 서버와 클라이언트 간의 연결 설정 없이 바로 데이터를 송수신 할 수 있다.
- **특징**
    - **간단한 통신 원리**: 클라이언트가 보낸 데이터를 서버가 그대로 되돌려주는 단순한 구조
    - **연결 없는 통신**: UDP는 연결 설정 없이 바로 데이터를 전송하므로, 빠르게 데이터를 주고받을 수 있다.
    - **신뢰성과 순서 보장 없음**: UDP는 패킷의 손실이나 순서 변경에 대해 관리하지 않는다.

## UDP Echo Server

```java
public class UDPEchoServer {
	private static final int PORT = 12345;
	private static final int BUFFER_SIZE = 1024;
	
	public static void main(String[] args) {
		try (DatagramSocket socket = new DatagramSocket(PORT)) {
			System.out.println("UDP Echo 서버 시작 (포트: " + PORT + ")");
			
			byte[] buffer = new byte[BUFFER_SIZE];
			
			while (true) {
				// 클라이언트가 보낼 메시지 수신
				DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
				socket.receive(packet);
				
				String message = new String(packet.getData(), 0, packet.getLength());
				System.out.println("받은 메시지::" + message);
				
				// 클라이언트가 보낸 메시지를 다시 클라이언트에게 전송
				// 데이터를 전송하기 위해 필요한 것 - 데이터, 데이터 크기, 클라이언트 IP, 클라이언트 PORT
				String responseMessage = "Echo::" + message;
				byte[] responseBuffer = responseMessage.getBytes();
				
				DatagramPacket sendPacket = new DatagramPacket(
								responseBuffer,
								responseBuffer.length,
								packet.getAddress(),
								packet.getPort()
				);
				
				socket.send(sendPacket);
				System.out.println("전송: " + responseMessage);
			}
		} catch (Exception e) {
			System.err.println("서버 오류: " + e.getMessage());
		}
	}
}
```

## UDP Echo Client

```java
public class UDPEchoClient {
	private static final String SERVER_HOST = "localhost";
	private static final int SERVER_PORT = 12345;
	private static final int BUFFER_SIZE = 1024;
	
	public static void main(String[] args) {
		try (DatagramSocket socket = new DatagramSocket();
					Scanner scanner = new Scanner(System.in)
		) {
			// 키보드로부터 서버에 전송할 문자를 입력 받고, 입력 받은 문자를 서버에 보낸다.
			
			// 서버의 IP를 추상화한 InetAddress를 생성한다.
			InetAddress serverAddress = InetAddress.getByName(SERVER_HOST);
			byte[] buffer = new byte[BUFFER_SIZE];
			System.out.println("서버에 보낼 메시지를 입력하세요. (quit: 종료)");
			
			while (true) {
				// 서버에 보낼 데이터 입력
				String message = scanner.nextLine();
				
				if ("quit".equalsIgnoreCase(message)) {
					break;
				}
				// 서버에 데이터를 전송하기 위해 DatagramPacket 생성
				byte[] sendData = message.getBytes();
				DatagramPacket sendPacket = new DatagramPacket(
							sendData,
							sendData.length,
							serverAddress,
							SERVER_PORT
				);
				// 데이터 전송
				socket.send(sendPacket);
				
				// 서버가 보낸 패킷을 받는 코드
				DatagramPacket receivePacket = new DatagramPacket(buffer, buffer.length);
				socket.receive(receivePacket);
				
				String responseMessage = new String(
							receivePacket.getData(),
							0,
							receivePacket.getLength()
				);
				System.out.println("서버 응답::" + responseMessage);
			}
		} catch (Exception e) {
			System.err.println("클라이언트 오류: " + e.getMessage());
		}
	}
}
```

## UDP 브로드캐스트

- UDP를 사용한 브로드캐스트 메시지 전송

```java
public class UDPBroadcast {
	public static void main(String[] args) {
		try (DatagramSocket socket = new DatagramSocket()) {
			socket.setBroadcast(true);
			
			String message = "브로드캐스트 메시지입니다.";
			byte[] buffer = message.getBytes();
			
			// 브로드캐스트 주소 (255.255.255.255)
			InetAddress broadcastAddress = InetAddress.getByName("255.255.255.255");
			
			DatagramPacket packet = new DatagramPacket(
						buffer,
						buffer.length,
						broadcastAddress,
						12345
			);
			
			socket.send(packet);
			System.out.println("브로드캐스트 메시지 전송 완료");
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
	}
}
```

## UDP vs TCP

| **특징** | **UDP Echo** | **TCP Echo** |
| --- | --- | --- |
| **연결 설정** | 불필요 | 필요 (3-Way Handshake) |
| **속도** | 빠름 | 상대적으로 느림 |
| **신뢰성** | 낮음 | 높음 |
| **데이터 순서** | 보장 없음 | 보장 |
| **오버헤드** | 낮음 | 높음 |
| **사용 예** | 실시간 스트리밍, 게임 | 웹 서비스, 이메일, 파일 전송 |

# 고급 네트워크 프로그래밍

## URL과 URLConnection

- **웹 리소스에 접근하기**

```java
public class URLDetailsExample {
	public static void main(String[] args) {
		try {
			// URL 객체 생성
			URL url = new URL("https://likelion.net");
			
			// URL 정보 출력
			System.out.println("프로토콜: " + url.getProtocol());
			System.out.println("호스트: " + url.getHost());
			System.out.println("포트: " + url.getPort());
			System.out.println("경로: " + url.getPath());
			
			// URLConnection으로 연결
			URLConnection connection = url.openConnection();
			connection.setConnectTimeout(5000);
			connection.setReadTimeout(5000);
			connection.getContentType(); // 보낸 내용의 타입
			
			// 헤더 정보 읽기
			System.out.println("\n=== 헤더 정보 ===");
			System.out.println("Content-Type: " + connection.getContentType());
			System.out.println("Content-Length: " + connection.getContentLength());
			
			// 내용 읽기
			try (BufferedReader br = new BufferedReader(
						new InputStreamReader(connection.getInputStream(), "UTF-8"))
			) {
				String line;
				
				while ((line = br.readLine()) != null) {
					System.out.println(line);
				}
			}
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
	}
}
```

## URL을 사용한 웹 콘텐츠 읽기

```java
public class SimpleURLReader {
	public static void main(String[] args) {
		try {
			URL url = new URL("http://naver.com");
			
			try (BufferedReader reader = new BufferedReader(
							new InputStreamReader(url.openStream()))
			) {
				String line;
				while ((line = reader.readLine()) != null) {
					System.out.println(line);
				}
			}
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
	}
}
```

## URLConnection을 사용한 데이터 전송

```java
public class URLConnectionPostExample {
	public static void main(String[] args) {
		try {
			URL url = new URL("http://www.httpbin.org/post");
			URLConnection connection = url.openConnection();
			
			// POST 요청 설정
			connection.setDoOutput(true);
			connection.setRequestProperty("Content-Type", "application/json");
			
			// 데이터 전송
			String jsonData = "{\"message\": \"Hello from Java!\"}";
			try (OutputStreamWriter writer = new OutputStreamWriter(
						connection.getOutputStream())
			) {
				writer.write(jsonData);
			}
			
			// 응답 읽기
			try (BufferedReader br = new BufferedReader(
						new InputStreamReader(connection.getInputStream()))
			) {
				String line;
				while ((line = br.readLine()) != null) {
					System.out.println(line);
				}
			}
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
	}
}
```

# HTTP 클라이언트 구현

## 간단한 HTTP 클라이언트

```java
public class SimpleHttpClient {
	public static void main(String[] args) {
		String hostname = "www.google.com";
		int port = 80;
		
		try (Socket socket = new Socket(hostname, port);
					PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);
					BufferedReader reader = new BufferedReader(new InputStreamReader(
								socket.getInputStream()))
		) {
			// HTTP GET 요청 전송
			writer.println("GET /HTTP/1.1");
			writer.println("Host: " + hostname);
			writer.println("Connection: close");
			writer.println(); // 빈 줄로 헤더 종료
			
			// 응답 읽기
			String responseLine;
			while ((responseLine = reader.readLine()) != null) {
				System.out.println(responseLine);
			}
		} catch (Exception e) {
			System.err.println("HTTP 요청 실패: " + e.getMessage());
		}
	}
}
```

- `HttpURLConnection`: Java가 오랫동안 기본으로 제공해 온 표준 HTTP 클라이언트이다.
- `HttpClient` (**Java 11+**): 비동기 통신과 HTTP/2를 지원하는 더 현대적이고 유연한 API로, 새로운 프로젝트에서는 사용이 적극 권장된다.

# 네트워크 프로그래밍 베스트 프랙티스

## 예외처리

- 네트워크 프로그래밍에서는 외부 요인으로 인한 예외가 자주 발생한다.
- 네트워크 지연, 연결 중단 등 다양한 예외 상황에 대비하여 **견고한 예외 처리**는 필수이다.
- 주요 네트워크 예외
    - `IOException`: 네트워크 연결 실패, 데이터 전송 중 오류 등 대부분의 입출력 문제
    - `UnknownHostException`: 호스트 이름(도메인)을 IP 주소로 변환할 수 없을 때 (DNS 조회 실패)
    - `SocketTimeoutException`: 지정된 시간 내에 연결 또는 데이터 읽기가 완료되지 않았을 때
    - `ConnectException`: 서버가 해당 포트에서 대기하고 있지 않거나 연결을 거부했을 때

## 동기화와 스레드

- 여러 클라이언트가 동시에 접속하는 상황은 매우 일반적이므로, **멀티스레딩**과 **동기화** 개념이 중요하다.
- **스레드 풀 사용**
    - 클라이언트가 접속할 때마다 `new Thread()`로 새로운 스레드를 만드는 것은 시스템에 큰 부담을 준다.
    - `ExecutorService` (**스레드 풀**)를 사용하여 스레드를 재사용하고 서버의 과부하를 막는 것이 표준적인 방식이다.
- **공유 자원 동기화**
    - 여러 스레드가 동시에 접속자 목록과 같은 공유 자원에 접근할 때는 `ConcurrentHashMap` 같은 **스레드 안전(Thread-Safe)한 컬렉션**을 사용하거나, `synchronized` 블록으로 접근을 제어해야 데이터의 무결성을 보장할 수 있다.

## 보안 및 자원 관리

- **입력 검증**
    - 클라이언트로부터 받은 데이터는 항상 신뢰할 수 없다고 가정하고, 사용하기 전에 반드시 유효성을 검증해야 한다. (예: 길이, 형식 등)
- **안전한 자원 관리**
    - 소켓, 스트림 등의 리소스는 사용 후 반드시 닫아야 자원 누수를 막을 수 있다.
    - `try-with-resources` 구문을 사용하는 것이 가장 안전하고 권장되는 방법이다.
- **Dos 공격 방지**
    - 비정상적으로 많은 연결 요청이나 대용량 데이터를 보내는 공격에 대비해서, 최대 연결 수 제한, 적절한 타임아웃 설정 등을 고려해야 한다.

## API 선택과 데이터 처리

- **상황에 맞는 API 선택**
    - `Socket`: HTTP 등 프로토콜의 동작 원리를 학습하거나, 비표준 프로토콜을 구현할 때 사용한다.
    - `HttpURLConnection`: Java의 전통적인 HTTP 통신 방법으로, 레거시 시스템에서 필요할 수 있다.
    - `HttpClient` (Java 11+): 비동기, HTTP/2를 지원하는 현대적인 표준 방식으로, 새로운 프로젝트에서는 사용이 적극 권장된다.
- **정확한 데이터 처리**
    - UDP 통신 등에서 버퍼(`byte[]`)를 문자열로 변환할 때는, 버퍼 전체가 아닌 **실제로 수신된 데이터의 길이**(`getLength()`)만큼만 사용해야 데이터 오염을 막을 수 있다.
