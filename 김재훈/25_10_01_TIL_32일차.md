# 네트워크 기본 개념

## IP주소의 의해

- **IP 주소(Internet Protocol Address)**는 인터넷에 연결된 모든 장치에 할당된 고유한 주소이다.
- IP 주소 확인 방법
    - Windows: `ipconfig` 명령어 사용
    - Linux/Mac: `ifconfig` 명령어 사용

## IPv4와 IPv6

- **IPv4 (Internet Protocol version 4)**
    - 32비트 길이로 2^32개(약 43억개)의 IP 표현 가능
    - 점으로 구분된 4개의 옥텟으로 표현 (예: 192.168.0.1)
    - 주소 고갈 문제로 IPv6 등장
- **IP 주소의 구성**
    
    
    |  | **IPv4 주소** | **IPv6 주소** |
    | --- | --- | --- |
    | **주소 체계** | 32bit (2^32개) | 128bit (2^128개) |
    | **주소 표기** | 10진수 | 16진수 |
    | **주소 구성** | 8bit씩 4개의 옥텟 | 16bit씩 8개의 필드 |
    | **주소 예제** | 192.168.1.1 | 2002:1032:bc:198:1:13:113:19 |

## IP 주소 체계

- **서브넷 마스크(Subnet Mask)**
    - 서브넷 마스크는 IP 주소에서 **네트워크 ID**와 **호스트 ID**를 구분하는 역할을 한다.
    
    <img width="893" height="230" alt="Image" src="https://github.com/user-attachments/assets/79d83190-5b56-4220-8af3-d02a26ac62b5" />
    
- **IP 주소 구성**
    - **Netwrok ID**: 하나의 조직, 그룹으로 Host들을 관리하기 위한 식별자
    - **Host ID**: 호스트들을 개별적으로 관리하기 위한 식별자
    - **IP address = Network ID + Host ID**
- IP 클래스
    
    <img width="663" height="428" alt="Image" src="https://github.com/user-attachments/assets/2f7d0601-b4de-44d6-b7f2-0d693eeb445c" />
    
    | **클래스** | **네트워크 ID** | **호스트 ID** | **최대 호스트 수** |
    | --- | --- | --- | --- |
    | A | 8비트 | 24비트 | 16,772,214개 |
    | B | 16비트 | 16비트 | 65,534개 |
    | C | 24비트 | 8비트 | 254개 |

## 공인 IP와 사설 IP

- **공인 IP (Public IP)**
    - ISP(인터넷 서비스 공급자)가 제공하는 전세계적으로 유일한 IP 주소
    - 외부에서 직접 접근 가능
    - 방화벽 등의 보안 설정 필요
- **사설 IP (Private IP)**
    - 가정이나 회사 내부 네트워크에서 사용
    - 외부에서 직접 접근 불가능
    - NAT(Network Address Translation)를 통해 인터넷 접속
    - 주소 대역
        - **Class A**: 10.0.0.0 ~ 10.255.255.255
        - **Class B**: 172.16.0.0 ~ 172.31.255.255
        - **Class C**: 192.168.0.0 ~ 192.168.255.255

|  | **공인 IP (Public IP)** | **사설 IP (Private IP)** |
| --- | --- | --- |
| **할당 주체** | ISP (인터넷 서비스 공급자) | 라우터 (공유기) |
| **할당 대상** | 개인 또는 회사의 서버 (라우터) | 개인 또는 회사의 기기 |
| **고유성** | 인터넷 상에서 유일한 주소 | 하나의 네트워크 안에서 유일 |
| **공개 여부** | 내/외부 접근 가능 | 외부 접근 불가능 |

## 포트 번호

- 포트번호는 호스트 내의 특정 프로세스나 서비스를 식별하는 16비트 숫자이다.

| **범위** | **용도** |
| --- | --- |
| 0 ~ 1023 | Well-known ports 
- HTTP:80, HTTPS:443, FTP:21, SSH:22, DNS:53, SMTP:25, MySQL: 3306 |
| 1024 ~ 49151 | Registered ports |
| 49152 ~ 65535 | Dynamic/Private ports |

# TCP 통신의 이해

## TCP(Transmission Control Protocol)의 특징

- **TCP**는 신뢰성 있는 데이터 전송을 보장하는 연결 지향적 프로토콜이다.
- OSI 7계층 중 전송 계층(Transport Layer, 4계층)에 속한다.
- **주요 특징**
    - **연결 지향적**: 데이터 전송 전 연결 설정이 필요하다.
    - **신뢰성 보장**: 패킷 손실 시 재전송한다.
    - **순서 보장**: 전송 순서대로 데이터가 도착한다.
    - **흐름 제어**: 수신자 처리 속도에 맞춰 전송한다.
    - **혼잡 제어**: 네트워크 부하를 조절한다.

## TCP 3-Way Handshake

- **3-Way Handshake**: TCP 연결은 3단계 핸드셰이크 과정을 통해 이루어진다.
- **데이터 전송**: 연결이 설정되면 데이터가 세그먼트라는 작은 단위로 나누어져 전송된다.
- **연결 종료**: 데이터 전송이 완료되면 연결을 종료하는 과정이 진행된다.
- 연결 설정 과정
    1. **SYN**: 클라이언트 → 서버 (연결 요청)
    2. **SYN + ACK**: 서버 → 클라이언트 (연결 수락)
    3. **ACK**: 클라이언트 → 서버 (연결 확인)

<img width="749" height="670" alt="Image" src="https://github.com/user-attachments/assets/83d21196-a0fb-4bc2-8a35-38aa69c70ae7" />

## TCP 프로그래밍의 기본 절차

1. **서버 생성**: `ServerSocket`을 생성하고, 특정 포트에서 클라이언트의 연결을 기다린다.
2. **클라이언트 연결 요청**: 클라이언트는 `Socket`을 사용하여 서버의 특정 포트로 연결을 요청한다.
3. **연결 수락 및 데이터 교환**: 서버는 클라이언트의 요청을 수락하고, `Socket`을 통해 데이터를 송수신한다.
4. **연결 종료**: 데이터 전송이 끝나면, 클라이언트와 서버 모두 연결을 종료한다.

# Java 네트워크 프로그래밍 기초

## InetAddress 클래스

- `InetAddress` 클래스는 자바에서 IP 주소를 표현하고 관리하기 위해 사용되는 클래스이다.
- `java.net` 패키지에 속해 있으며, IPv4와 IPv6 주소를 추상화하여 제공한다.
- 객체를 직접 생성할 수 없고, 정적 메서드를 통해 객체를 얻어야 한다.

## 주요 메서드

- **주소 조회 메서드**
    - `getByName(String host)`: 주어진 호스트 이름 또는 IP 주소에 대한 `InetAddress` 객체 반환
    - `getAllByName(String host)`: 주어진 호스트 이름에 대한 모든 IP 주소를 배열로 반환
    - `getLocalHost()`: 로컬 컴퓨터의 IP 주소를 포함하는 InetAddress 객체를 반환
- **주소 정보 검색 메서드**
    - `getHostName()`: 호스트의 이름을 반환
    - `getHostAddress()`: IP 주소를 문자열 형태로 반환
    - `getAddress()`: IP 주소를 바이트 배열로 반환
    - `isReachable(int timeout)`: 호스트가 주어진 시간 내에 도달 가능한지 검사

## 사용 예제

```java
public class InetAddressExample {
	public static void main(String[] args) throws IOException {
		// 특정 호스트의 IP 주소 조회
		InetAddress google = InetAddress.getByName("www.google.com");
		InetAddress naver = InetAddress.getByName("www.naver.com");
		
		System.out.println("Google_IP: " + google.getHostAddress());
		System.out.println("Naver_IP: " + naver.getHostAddress());
		
		System.out.println("Google_Host: " + google.getHostName());
		System.out.println("Naver_Host: " + naver.getHostName());
		
		// 도달 가능 여부
		boolean googleReachable = google.isReachable(3000);
		boolean naverReachable = naver.isReachable(3000);
		
		System.out.println("googleReachable: " + googleReachable);
		System.out.println("naverReachable: " + naverReachable);
		
		// 전체 IP 주소
		InetAddress[] allGoogle = InetAddress.getAllByName("www.google.com");
		InetAddress[] allNaver = InetAddress.getAllByName("www.naver.com");
		
		for (InetAddress all : allGoogle) {
			System.out.println("Google IP: " + all.getHostAddress());
		}
		
		for (InetAddress all : allNaver) {
			System.out.println("Naver IP: " + all.getHostAddress());
		}
		
		// 로컬 호스트의 IP 주소와 이름 조회
		InetAddress localHost = InetAddress.getLocalHost();
		System.out.println("LocalHost_Name: " + localHost.getHostName());
		System.out.println("LocalHost_IP: " + localHost.getHostAddress());
		
		// 바이트 배열로 IP 주소 확인
		byte[] ip = localHost.getAddress();
		System.out.print("Byte array format: ");
		for (int i = 0; i < ip.length; i++) {
			System.out.print((ip[i] & 0xFF)); // 부호 없는 바이트로 출력
			if (i != ip.length - 1) {
				System.out.print(".");
			}
		}
	}
}
```

- **주의사항**
    - 네트워크 관련 코드에서 예외 처리는 필수이다.
    - `isReachable` 메서드는 방화벽 설정이나 네트워크 구성에 따라 신뢰할 수 없는 결과를 반환할 수 있다.

# 기본 소켓 프로그래밍

## TCP Echo 서버 구현

- Echo 프로그래밍은 클라이언트가 서버에 메시지를 보내면, 서버가 동일한 메시지를 클라이언트에게 되돌려주는 간단한 네트워크 애플리케이션이다.

```java
public class SimpleEchoServer {
	private static final int PORT = 12345;
	
	public static void main(String[] args) {
		try (ServerSocket serverSocket = new ServerSocket(PORT)) {
			System.out.println("에코 서버가 포트 " + PORT + "에서 시작되었습니다.");
			
			while (true) {
				// 클라이언트 연결 대기
				try (Socket clientSocket = serverSocket.accept();
							BufferedReader reader = new BufferedReader(
									new InputStreamReader(clientSocket.getInputStream()));
							PrintWriter writer = new PrintWriter(
									clientSocket.getOutputStream(), true)
				) {
					System.out.println("클라이언트 연결::" + 
							clientSocket.getRemoteSocketAddress());
					
					String inputLine;
					while ((inputLine = reader.readLine()) != null) {
						System.out.println("클라이언트로부터 받은 메시지: " + inputLine);
						writer.println("Echo: " + inputLine);
						
						if ("bye".equalsIgnoreCase(inputLine)) {
							break;
						}
					}
				} catch (IOException e) {
					System.err.println("클라이언트 처리 중 오류: " + e.getMessage());
				}
			}
		} catch (IOException e) {
			System.err.println("서버 시작 실패: " + e.getMessage());
		}
	}
}
```

## 에코 클라이언트

```java
public class SimpleEchoClient {
	private static final String SERVER_HOST = "localhost";
	private static final int SERVER_PORT = 12345;
	
	public static void main(String[] args) {
		try (Socket socket = new Socket(SERVER_HOST, SERVER_PORT);
					BufferedReader reader = new BufferedReader(
							new InputStreamReader(socket.getInputStream()));
					PrintWriter writer = new PrintWriter(
							socket.getOutputStream(), true);
					// 키보드로 입력 받아서, 받은 내용을 서버에 전송
					Scanner scanner = new Scanner(System.in)
		) {
			System.out.println("서버 접속 성공!");
			System.out.println("메시지를 입력하세요 (bye 입력 시 종료)");
			
			while (true) {
				// 1. 사용자 입력 받기
				String message = scanner.nextLine();
				
				// 2. 입력된 내용 서버로 전송
				writer.println(message); // writer - 소켓
				
				// 3. 서버가 응답한 내용을 읽어옴
				String response = reader.readLine();
				
				// [안정성] 서버가 연결을 끊었을 경우 확인
				if (response == null) {
					System.out.println("서버와 연결이 끊어졌습니다.");
					break;
				}
				
				// 4. 서버가 응답한 내용을 콘솔에 출력
				System.out.println(response);
				
				// [가독성] "bye"를 보낸 후 루프 종료
				if (message.equalsIgnoreCase("bye")) {
					break;
				}
			}
		} catch (IOException e) {
			System.err.println("오류 발생: " + e.getMessage());
		}
		
		System.out.println("클라이언트를 종료합니다.");
	}
}
```

## 멀티스레드 서버

- 여러 클라이언트를 동시에 처리하는 서버 구현

```java
public class MultiThreadEchoServer {
	
	private static final int PORT = 12345;
	
	public static void main(String[] args) {
		
		ExecutorService es = Executors.newFixedThreadPool(5);
		
		try (ServerSocket serverSocket = new ServerSocket(PORT)) {
			System.out.println("에코서버가 포트 " + PORT + "에서 시작되었습니다.");
			
			while (true) {
				Socket socket = serverSocket.accept();
				
				/*
				클라이언트와 각각 통신할 수 있도록 클라이언트가 접속할 때 스레드 생성
				Thread clientThread = new Thread(new ClientThread(socket));
				clientThread.start();
				*/
				
				// 스레드 풀을 이용하는 방식으로 변경
				es.submit(new ClientHandler(socket));
			}
		} catch (IOException e) {
			System.err.println("서버 오류: " + e.getMessage());
		} finally {
			es.shutdown();
		}
	}
	
	static class ClientHandler implements Runnable {
		private final Socket socket;
		
		public ClientHandler(Socket socket) {
			this.socket = socket;
		}
		
		@Override
		public void run() {
			try (BufferedReader reader = new BufferedReader(
								new InputStreamReader(socket.getInputStream());
						PrintWriter writer = new PrintWriter(
								socket.getOutputStream(), true)
			) {
				SocketAddress clientAddress = socket.getRemoteSocketAddress();
				System.out.println(clientAddress + "사용자 접속");
				
				String inputLine;
				while ((inputLine = reader.readLine()) != null) {
					System.out.println(clientAddress + "로부터 받은 메시지: " + inputLine);
					writer.println("Echo: " + inputLine);
					
					if ("bye".equalsIgnoreCase(inputLine)) {
						break;
					}
				}
				
				System.out.println(clientAddress + " 연결 종료!");
			} catch (IOException e) {
				System.err.println("클라이언트 처리 오류: " + e.getMessage());
			} finally {
				try {
					socket.close();
				} catch (IOException e) {
					System.out.println("소켓 종료 오류: " + e.getMessage());
				}
			}
		}
	}
}
```

# TCP 채팅 프로그램

## 채팅 서버 구현

- 여러 클라이언트가 동시에 접속하여 메시지를 주고받을 수 있는 채팅 서버

```java
public class ChatServer {
	private static final int PORT = 12345;
	private static final Set<ClientHandler> clients = ConcurrentHashMap.newKeySet();
	
	public static void main(String[] args) {
		System.out.println("채팅 서버가 포트 " + PORT + "에서 시작되었습니다.");
		
		try (ServerSocket serverSocket = new ServerSocket(PORT)) {
			while (true) {
				Socket clientSocket = serverSocket.accept();
				ClientHandler clientHandler = new ClientHandler(socket);
				clients.add(clientHandler);
				new Thread(clientHandler).start();
			}
		} catch (IOException e) {
			System.err.println("서버 오류: " + e.getMessage());
		}
	}
	
	static class ClientHandler implements Runnable {
		private Socket socket;
		private PrintWriter writer;
		private String nickname;
		
		public ClientHandler(Socket socket) {
			this.socket = socket;
		}
		
		@Override
		public void run() {
			try (BufferedReader reader = new BufferedReader(
						new InputStreamReader(socket.getInputStream()))) {
				
				writer = new PrintWriter(socket.getOutputStream(), true);
				
				// 닉네임 설정
				writer.println("닉네임을 입력하세요:");
				nickname = reader.readLine();
				
				if (nickname == null || nickname.trim().isEmpty()) {
					return;
				}
				
				System.out.println(nickname + "님 입장");
				broadcast(nickname + "님 입장", this);
				
				String message;
				while ((message = reader.readLine()) != null) {
					System.out.println(nickname + "님으로부터 받은 메시지::" + message);
					if ("bye".equalsIgnoreCase(message)) {
						break;
					}
					broadcast(nickname + ": " + message, this);
				}
			} catch (IOException e) {
				System.err.println("클라이언트 처리 오류: " + e.getMessage());
			} finally {
				if (nickname != null) {
					System.out.println(nickname + "님 퇴장");
					broadcast(nickname + "님 퇴장", this);
				}
				clients.remove(this);
				
				try {
					socket.close();
				} catch (IOException e) {
					System.err.println("소켓 종료 오류: " + e.getMessage());
				}
			}
		}
		
		public void sendMessage(String message) {
			if (writer != null) {
				writer.println(message);
			}
		}
	}
	
	private static void broadcast(String message, ClientHandler sender) {
		for (ClientHandler client : clients) {
			if (client != sender) {
				client.sendMessage(message);
			}
		}
	}
}
```

## 채팅 클라이언트 구현

```java
public class ChatClient {
	private static final String SERVER_HOST = "localhost";
	private static final int SERVER_PORT = 12345;
	
	public static void main(String[] args) {
		try (Socket socket = new Socket(SERVER_HOST, SERVER_PORT);
					BufferedReader reader = new BufferedReader(
							new InputStreamReader(socket.getInputStream()));
					PrintWriter writer = new PrintWriter(
							socket.getOutputStream(), true);
					// 키보드 입력을 받기 위해서
					Scanner scanner = new Scanner(System.in);
		) {
			// 서버가 보내준 메시지를 읽어오는 일 담당
			Thread readerThread = new Thread(() -> {
				try {
					String serverMessage;
					while ((serverMessage = reader.readLine()) != null) {
						System.out.println(serverMessage);
					}
				} catch (IOException e) {
					System.err.println("서버 연결이 끊어졌습니다.");
				}
			});
			
			readerThread.start();
			
			// 사용자의 입력을 받아서 서버에게 전송하는 일 담당
			String userInput;
			while (!(userInput = scanner.nextLine()).equalsIgnoreCase("bye")) {
				writer.println(userInput);
			}
			writer.println("bye");
		
		} catch (IOException e) {
			System.err.println("서버 연결 실패: " + e.getMessage());
		}
	}
}
```
