> 반복문에서 `println()`을 사용하면 출력이 너무 길어지므로 예제 출력 시 주로 `print()`를 사용했다.
> 

# while문

## while

- 반복문 중 하나이며, `탈출 조건식`이 `false`일 때 반복을 종료한다.
    
    ```java
    변수의 초기화
    while (탈출 조건식) {
    	// 조건이 참일 때 실행되는 코드
    	변수의 증감식;
    }
    ```
    
- 예제: 1 ~ 5까지 출력
    
    ```java
    int i = 1;
    while (i <= 5) {
    	System.out.print(i + " ");
    	i++;
    }
    
    /*
    실행 결과
    1 2 3 4 5
    */
    ```
    

## while문과 break

- `break`를 만나면 반복을 즉시 종료하며, 주로 `if`문과 함께 사용한다.
- 예제: 무한루프 + break
    
    ```java
    int i = 1;
    while (true) {
    	if (i == 11) break;
    	System.out.print(i + " ");
    	i++;
    }
    
    /*
    실행 결과
    1 2 3 4 5 6 7 8 9 10
    */
    ```
    
    - `i`의 값이 11이 되면 `break`를 만나며 즉시 반복문이 종료된다.

## while문과 continue

- `continue`를 만나면 현재 반복을 건너뛰고 다음 반복으로 바로 넘어간다.
- 예제: 짝수만 출력
    
    ```java
    int i = 0;
    while (i++ < 10) {
    	if (i % 2 != 0) 
    		continue;
    	System.out.print(i + " ");
    }
    
    /*
    실행 결과
    2 4 6 8 10
    */
    ```
    
    - `i`의 값이 짝수일 때 `continue`를 만나 현재 반복을 건너뛰고 다음 반복으로 넘어간다.

## while문과 후위 증감식

- 후위 증감식과 전위 증감식의 출력을 비교해보자.
- 후위 증감식
    
    ```java
    // 후위 증감식
    int i = 0;
    while (i++ < 10) {
    	System.out.print(i + " ");
    }
    
    /*
    실행 결과
    1 2 3 4 5 6 7 8 9 10
    */
    ```
    
    - 후위 증감식에서는 탈출 조건식을 통과한 후 값이 증가하기 때문에 10까지 출력이 된다.
- 전위 증감식
    
    ```java
    //전위 증감식
    int i = 0;
    while (++i < 10) {
    	System.out.print(i + " ");
    }
    
    /*
    실행 결과
    1 2 3 4 5 6 7 8 9
    */
    ```
    
    - 전위 증감식은 탈출 조건식을 비교하는 시점에 값이 10으로 증가한다.
    - 따라서 `i`가 10이 되는 시점에 탈출 조건식이 `false`가 되므로 반복이 종료된다.

# do-while문

- `while`문과 비슷하지만, **무조건 한 번은 실행**한 후 탈출 조건식을 비교한다는 특징이 있다.
    
    ```java
    변수의 초기화
    do {
    	// 반복 실행할 코드
    	변수의 증감식;
    } while (탈출 조건식);
    ```
    
- 예제: 1 ~ 5까지 출력
    
    ```java
    int i = 1;
    do {
    	System.out.print(i + " ")
    	i++;
    } while (i <= 5);
    
    /*
    실행 결과
    1 2 3 4 5
    */
    ```
    
- 예제: 탈출 조건식이 false 여도 한 번은 실행
    
    ```java
    int i = 10;
    do {
    	System.out.println(i)
    	i++;
    } while (i < 5);
    
    /*
    실행 결과
    10
    */
    ```
    

---

# for문

## for

- while문은 변수 선언, 탈출 조건식, 증감식이 각각 이루어져 총 3줄이지만, for문은 한 줄에 모두 표현한다.
    
    ```java
    for (변수의 초기화; 탈출조건식; 증감식) {
    	탈출 조건식이 참인 경우 실행되는 부분
    }
    ```
    
- 예제: “*”을 10번 출력
    
    ```java
    for (int i = 0; i < 10; i++) {
    	System.out.print("*");
    }
    
    /*
    실행 결과
    **********
    */
    ```
    

## 무한 루프

- for문의 모든 조건을 생략하면 무한 루프가 발생한다. 이 경우에는 break로 탈출이 필요하다.
    
    ```java
    // 조건식을 생략하면 무한 루프
    for (;;) {
    	System.out.println("무한 루프");
    	break; // break 로 탈출 필요
    }
    ```
    

## 중첩 반복문

- 반복문 안에 조건식이 올 수 있는 것처럼, 반복문 안에 반복문도 올 수 있다.
- 예제: 구구단 전체 출력
    
    ```java
    for (int i = 2; i <= 9; i++) {
    	for (int j = 1; j <= 9; j++) {
    		System.out.pritln(i + " * " + j + " = " + (i * j));
    	}
    	System.out.println(); // 단 구분을 위한 줄바꿈
    }
    
    /*
    실행 결과(일부)
    2 * 1 = 2
    2 * 2 = 4
    ...
    9 * 8 = 72
    9 * 9 = 81
    */
    ```
    

### 연습

- 왼쪽 직각 삼각형 출력
    
    ```java
    for (int i = 0; i < 5; i++) {
    	for (int j = 0; j <= i; j++) {
    		System.out.println("*");
    	}
    }
    
    /*
    실행 결과
    *
    **
    ***
    ****
    *****
    */
    ```
    
- 왼쪽 직각 역삼각형 출력
    
    ```java
    for (int i = 0; i < 5; i++) {
    	for (int j = 0; j < 5 - i; j++) {
    		System.out.print("*");
    	}
    	System.out.println();
    }
    
    /*
    실행 결과
    *****
    ****
    ***
    **
    *
    */
    ```
    
- 오른쪽 직각 삼각형 출력
    
    ```java
    for (int i =0; i < 5; i++) {
    	for (int j = 1; j < 5 - i; j++) {
    		System.out.print(" ");
    	}
    	for (int k = 0; k <= i; k++) {
    		System.out.print("*");
    	}
    	System.out.pritln();
    }
    
    /*
    실행 결과
        *
       **
      ***
     ****
    *****
    */
    ```
    
- 오른쪽 직각 역삼각형 출력
    
    ```java
    for (int i = 0; i < 5; i++) {
    	for (int j = 0; j < i; j++) {
    		System.out.print(" ");
    	}
    	for (int k = 0; k < 5 - i; k++) {
    		System.out.print("*");
    	}
    	System.out.println();
    }
    
    /*
    실행 결과
    *****
     ****
      ***
       **
        *
    */
    ```
    
- 정삼각형 출력
    
    ```java
    for (int i = 1; i <= 5; i++) {
    	for (int j = 1; j <= 5 - i; j++) {
    		System.out.print(" ");
    	}
    	for (int k = 1; k <= 2 * i - 1; k++) {
    		System.out.print("*");
    	}
    	System.out.pritln();
    }
    
    /*
    실행 결과
        *
       ***
      *****
     *******
    *********
    */
    ```
    

## 반복문과 label

- label은 중첩 반복문에서 특정 반복문을 제어하고 싶을 때 사용한다.
- 예제: label과 break
    
    ```java
    outer:
    for (int i = 0; i < 3; i++) {
    	for (int j = 0; j < 3; j++) {
    		if (i == 0 && j == 2) {
    			break; // 바깥쪽 반복문까지 모두 종료
    		}
    	    System.out.println(i + ", " + j);
        }
    }
    
    /*
    실행 결과
    0, 0
    0, 1
    */
    ```
    
    - break를 만나면 바깥쪽 반복문까지 모두 종료된다.
- 예제: label과 continue
    
    ```java
    outer:
    for (int i = 0; i < 3; i++) {
    	for (int j = 0; j < 3; j++) {
    		if (i == 0 && j == 2) {
    			continue; // 안쪽 반복문을 종료하고, 바깥쪽 반복문의 다음 반복으로
    		}
    	    System.out.println(i + ", " + j);
        }
    }
    
    /*
    실행 결과
    0, 0
    0, 1
    1, 0
    1, 1
    1, 2
    2, 0
    2, 1
    2, 2
    */
    ```
    
    - continue를 만나면 안쪽 반복문을 종료하고, 바깥쪽 반복문의 다음 반복문을 시작한다.
- label 사용 주의
    - 코드의 가독성을 해칠 수 있으므로 꼭 필요한 경우에만 사용해야 한다.
    - 대부분의 경우 메서드 분리나 플래그 변수로 대체할 수 있다.

## 문자열과 반복문 활용

- 문자열과 숫자, boolean을 더하면 문자열로 자동 변환된다.
    
    ```java
    String str1 = "hello" + 1;
    String str2 = "hello" + true;
    String str3 = "hello" + 50.4;
    
    System.out.println(str1);
    System.out.println(str2);
    System.out.println(str3);
    
    /*
    실행 코드
    hello1
    hellotrue
    hello50.4
    */
    ```
    

## for문 vs while문 선택 기준

- 반복 횟수가 명확한 경우: `for`문 사용
    - 이유: 초기화, 조건, 증감이 한 줄에 표현되므로 가독성이 뛰어나다.
- 반복 횟수가 불명확한 경우: `while`문 사용
    - 이유: 반복 조건만 명시하면 되기 때문이다.
- 컬렉션을 순회하는 경우: `for-each`문
    - 이유: 간결하고 안전하기 때문이다.
- 무한 루프가 필요한 경우: `while (true)`
    - 이유: `for(;;)`를 사용하는 것보다 가독성이 좋다.

---

# 배열

## 배열이란?

- 동일한 타입의 여러 값을 하나의 변수로 관리하는 것이다.
- 연속된 메모리 공간에 순차적으로 저장된다.
- 인덱스(index)를 통해 각 요소에 접근할 수 있는데, 인덱스는 0부터 시작한다.
- 한 번 생성된 배열의 크기는 변경이 불가능하다. (추후 배울 자료구조에서는 유동적으로 변하는 것도 있다.)
- 배열의 장단점
    - 장점
        - 인덱스로 빠른 접근이 가능하다.
        - 메모리 관리가 효율적이다.
        - 반복문과 함께 사용하기가 편리하다.
    - 단점
        - 크기가 고정적이라 요소를 추가하려면 배열을 새로 만들어야 한다.
        - 중간에 삽입과 삭제가 어렵다. (이 부분도 추후 배울 자료구조를 통해 해결이 가능한 것도 있다.)
        - 같은 타입만 저장이 가능하다. (Object 타입은 모든 객체의 부모이므로 모든 객체를 담을 수 있다.)
- 배열의 타입별 기본값
    - 정수형: 기본값은 0으로, `int[] arr = new int[3];`과 같이 정의한다.
    - 실수형: 기본값은 0.0으로, `double[] arr = new double[2];`와 같이 정의한다.
    - 문자형: 기본값은 \0(공백)으로, `char[] arr = new char[2];`와 같이 정의한다.
    - 논리형: 기본값은 false로, `boolean[] arr = new boolean[2];`와 같이 정의한다.
    - 참조형: 기본값은 null로, `String[] arr = new String[2];`와 같이 정의한다.

## 배열의 선언과 초기화

- 배열 선언
    
    ```java
    // 방법1: 타입[] 변수명(권장)
    int[] scores;
    String[] names;
    
    // 방법2: 타입 변수명[] 잘 사용하지 않는다.
    int scores2[];
    String names[];
    ```
    
- 배열 생성과 초기화
    
    ```java
    // 1. new 연산자로 생성하고, 기본값으로 초기화
    int[] intArr1 = new int[5]; // {0, 0, 0, 0, 0}
    boolean[] booleanArr1 = new boolean[3]; // {false, false, false}
    String[] stringArr2 = new String[3]; // {null, null, null}
    
    // 2. 선언과 동시에 초기화
    int[] intArr2 = {10, 20, 30, 40, 50};
    boolean[] booleanArr2 = {true, false, true};
    String[] stringArr2 = {"a", "b", "c"};
    
    // 3. new 연산자로 생성하면서 동시에 초기화
    int[] intArr3 = new int[]{10, 20, 30, 40. 50}
    boolean[] booleanArr3 = new boolean[]{true, false, true};
    String[] stringArr3 = new String[]{"a", "b", "c"};
    
    // 4. 선언 후 나중에 초기화
    // 배열을 선언 후 나중에 초기화 할 때는 반드시 new 키워드를 사용해야 한다.
    int[] intArr4;
    boolean[] booleanArr4;
    String[] stringArr4;
    
    intArr4 = new int[5];
    booleanArr4 = new boolean[3];
    stringArr4 = new String[3];
    ```
    
- 배열 요소에 접근 및 수정
    
    ```java
    int[] arr = new int[3];
    
    // 배열 요소 접근 및 수정
    arr[0] = 100;
    arr[1] = 200;
    
    System.out.println("arr[0] = " + arr[0]);
    System.out.println("arr[1] = " + arr[1]);
    
    /*
    실행 결과
    100
    200
    */
    ```
    

## 배열 활용

- 배열 순회
    
    ```java
    int[] scores = {95, 87, 66, 73, 82};
    
    // 1. 기본 for문으로 순회
    for (int i = 0; i < scores.length; i++) {
    	System.out.println("scores[" + i + "] = " + scores[i]);
    }
    
    // 2. 총점과 평균 계산
    long sum = 0;
    for (int i = 0; i < scores.length; i++) {
    	sum += scores[i];
    }
    
    double avg = (double) sum / scores.legnth;
    
    System.out.println("sum = " + sum);
    System.out.println("avg = " + avg);
    
    // 3. 최대값 찾기
    int max = scores[0];
    for (int i = 1; i < scores.length; i++) {
    	if (scores[i] > max) {
    		max = scores[i];
    	}
    }
    System.out.println("max = " + max);
    
    /*
    실행 결과
    scores[0] = 95
    scores[1] = 87
    scores[2] = 66
    scores[3] = 73
    scores[4] = 82
    
    sum = 403
    avg = 80.6
    max = 95
    */
    ```
    
- 향상된 for문(for-each문)(Enhanced for loop)
    - 코드가 간결하고 가독성이 좋아진다는 장점이 있다.
    - 인덱스를 사용할 수 없고, 역순으로 순회가 불가능하다는 단점이 있다.
    - 인덱스가 필요 없고, 순차적인 순회가 필요한 경우에 주로 사용한다.
    
    ```java
    for (배열자료형 변수명 : 배열변수명) {
    	// 실행할 코드
    }
    ```
    
    ```java
    String fruits = {"apple", "banana", "orange", "grape");
    
    // 향상된 for문
    for (String fruit : fruits) {
    	System.out.println("- " + fruit);
    }
    
    // 숫자 배열의 합계
    int[] numbers = {10, 20, 30, 40, 50};
    int sum = 0;
    for (int number : numbers) {
    	sum += number;
    }
    System.out.println("sum = " + sum);
    
    /*
    실행 결과
    - apple
    - banana
    - orange
    - grape
    
    sum = 150
    */
    ```
    
- ArrayIndexOutOfBoundsException
    - 배열의 인덱스 범위를 초과했을 때 발생하는 예외이다.
    
    ```java
    int[] arr = new int[3]; // 인덱스: 0, 1, 2
    
    try {
    	arr[0] = 10;
    	arr[1] = 20;
    	arr[2] = 30;
    	arr[3] = 40; // 예외가 발생한다!
    } catch (ArrayIndexOutOfBoundsException e) {
    	System.out.println("배열 인덱스 범위 초과!");
    	System.out.println("배열 길이: " + arr.length);
    	System.out.println("유효한 인덱스: 0 ~ " + (arr.legnth - 1));
    }
    
    /*
    실행 결과
    배열 인덱스 범위 초과!
    배열 길이: 3
    유효한 인덱스: 0 ~ 2
    */
    ```
    

## 배열 복사

- 배열 복사 방법
    
    ```java
    int[] original = {1, 2, 3, 4, 5};
    
    // 1. for문을 이용한 복사
    int[] copy1 = new int[original.length];
    for (int i = 0; i < original.length; i++) {
    	copy1[i] = original[i];
    }
    
    // 2. System.arrayCopy() 사용
    // arrayCopy(Object src, int srcPos, Object dest, int destPos, int length)
    int[] copy2 = new int[original.length];
    System.arrayCopy(original, 0, copy2, 0, original.length);
    
    // 3. Arrays.copyOf() 사용
    // copyOf(Object[] original, int newLength)
    int[] copy3 = Arrays.copyOf(original, original.length);
    
    // 4. Arrays.copyOfRange() 사용 (부분 복사)
    // copyOfRange(Object[] original, int from, int to)
    int[] copy4 = Arrays.copyOfRange(original, 1, 4); // 인덱스 1 ~ 3
    
    // 결과 출력
    System.out.println("original = " + Arrays.toString(original));
    System.out.println("copy1 = " + Arrays.toString(copy1));
    System.out.println("copy2 = " + Arrays.toString(copy2));
    System.out.println("copy3 = " + Arrays.toString(copy3));
    System.out.println("copy4 = " + Arrays.toString(copy4));
    
    /*
    실행 결과
    original = [1, 2, 3, 4, 5]
    copy1 = [1, 2, 3, 4, 5]
    copy2 = [1, 2, 3, 4, 5]
    copy3 = [1, 2, 3, 4, 5]
    copy4 = [1, 2, 3, 4, 5]
    */
    ```
    
- 얕은 복사 vs 깊은 복사 확인
    - 얕은 복사는 주소값을 복사하는 것이다.
    - 깊은 복사는 실제 값을 새로운 메모리 공간에 복사하는 것이다.
    
    ```java
    int[] numbers = {10, 20, 30}
    int[] shallow = numbers;
    int[] deep = Arrays.copyOf(numbers, numbers.length);
    
    shallow[1] = 200;
    deep[2] = 300;
    
    System.out.println("numbers = " + Arrays.toString(numbers));
    System.out.println("shallow = " + Arrays.toString(shallow));
    System.out.println("deep = " + Arrays.toString(deep));
    
    /*
    실행 결과
    numbers = [10, 200, 30]
    shallow = [10, 200, 30]
    deep = [10, 20, 300]
    */
    ```
    
    - 얕은 복사는 주소값을 복사하는 것이기 때문에 배열의 값이 함께 변하는 것을 확인할 수 있다.
    - 깊은 복사는 실제 값만 새로운 메모리 공간에 복사하기 때문에 해당 배열의 값만 변한다.

## Arrays 유틸리티 클래스

- `Arrays` 클래스에 있는 메서드에 대해 알아보자.
    
    ```java
    int[] numbers = {5, 2, 8 ,1, 9, 3};
    
    // 1. toString() - 배열 내용 출력
    System.out.println("numbers = " + Arrays.toString(numbers));
    
    // 2. sort() - 정렬
    int[] sorted = Arrays.copyOf(numbers, numbers.length);
    Arrays.sort(sorted);
    System.out.println("sorted = " + Arrays.toString(sorted));
    
    // 3. binarySearch() - 이진 탐색(정렬된 배열에서만 가능하다.)
    int index = Arrays.binarySearch(sorted, 5); // sorted 배열에서 5의 인덱스 찾기
    System.out.println("5의 위치: " + index);
    
    // 4. equals() - 배열 비교(메모리 주소값이 아닌 배열의 실제 값을 비교한다.)
    // 메모리 주소값 비교는 단순히 배열을 `==` 비교하면 된다.
    int[] arr1 = {1, 2, 3}
    int[] arr2 = {1, 2, 3}
    int[] arr3 = {1, 2, 4}
    
    // 메모리 주소값 비교
    System.out.println("arr1 == arr2: " + arr1 == arr2);
    System.out.println("arr1 == arr3: " + arr1 == arr3);
    
    // 배열의 실제 값 비교
    System.out.println("arr1 equals arr2: " + Arrays.equals(arr1, arr2));
    System.out.println("arr1 equals arr3: " + Arrays.equals(arr1, arr3));
    
    // 5. fill() - 배열 채우기
    int[] filled = new int[5];
    Arrays.fill(filled, 7);
    System.out.println("filled = " + Arrays.toString(filled));
    
    /*
    실행 결과
    numbers = [5, 2, 8, 1, 9, 3]
    sorted = [1, 2, 3, 5, 8, 9]
    5의 위치: 3
    arr1 == arr2: false
    arr1 == arr3: false
    arr1 equals arr2: true
    arr1 equals arr3: false
    filled = [7, 7, 7, 7, 7]
    */
    ```
