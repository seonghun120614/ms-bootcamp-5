# 다차원 배열

## 2차원 배열

- 배열이란, 동일한 타입의 여러 값을 하나의 변수로 관리하는 것이다.
- 1차원 배열은 1열로 된 저장공간이라면, 2차원 배열은 행렬을 생각하면 된다.
- 행렬과 마찬가지로 가로열이 행(row), 세로열이 열(column)이다.
- 메모리 용량이 허용하는 한 다차원 배열에 제한은 없지만, 가용성 차원에서 주로 1, 2차원 배열이 사용된다.

## 2차원 배열 선언과 초기화

- 2차원 배열을 선언할 때는 대괄호(`[]`)를 두 번 사용하여 선언하며, 첫 번째 괄호에 세로(열)의 크기, 두 번째 괄호에 가로(행)의 크기를 지정한다.
    
    ```java
    int intArr[][] = new int[세로크기][가로크기];
    ```
    
- 2차원 배열을 선언과 동시에 초기화 할 때는 1차열 배열과 같이 중괄호(`{}`)를 사용하여 선언할 수 있다.
    
    ```java
    자료형 변수명[][] = {
    				{가로 요소 크기}
    				{가로 요소 크기}
    				{가로 요소 크기}
    }; // 세로 3줄
    ```
    
- 1차원 배열과 마찬가지로 인덱스는 0부터 시작하지만, 행 인덱스와 열 인덱스를 따로 관리한다. 요소에 접근할 때는 `배열이름[행 인덱스][열 인덱스]`로 접근한다.
    
    ```java
    int[][] scores = {
    				{60, 70, 80},
    				{70. 80. 90}
    }
    
    /*
    score[0][0] = 60;
    score[0][1] = 70;
    score[0][2] = 80;
    score[1][0] = 70;
    score[1][1] = 80;
    score[1][2] = 90;
    */
    ```
    
- 2차원 배열의 길이를 구할 때는 `배열이름.length`로는 행의 길이, `배열이름[i].length`로는 열의 길이를 구할 수 있다.
    
    ```java
    int[][] scores = {
    				{60, 70, 80},
    				{70. 80. 90}
    }
    
    /*
    scores.length = 2
    scores[0].length = 3
    scores[1].length = 3
    */
    ```
    

## 2차원 배열 예제와 활용

- 2차원 배열 예제
    
    ```java
    // 2차원 배열 선언과 초기화
    int[][] matrix = {
    				{1, 2, 3},
    				{4, 5, 6},
    				{7, 8, 9}
    }
    
    // 2차원 배열 순회(for문)
    System.out.println("===== 2차원 배열 출력 =====")
    for (int row = 0; row < matrix.length; row++) {
    	for (int column = 0; column < matrix[row].length; column++) {
    		System.out.print(matrix[row][column] = " ");
    	}
    	System.out.println();
    }
    
    // 2차원 배열 순회(향상된 for문)
    System.out.println("===== 향상된 for문 =====")
    for (int[] row : matrix) {
    	for (int column : row) {
    		System.out.print(column + " ");
    	}
    	System.out.println();
    }
    
    // 가변 길이 2차원 배열
    int[][] jagged = new int[3][];
    jagged[0] = new int[]{1, 2};
    jagged[1] = new int[]{3, 4, 5};
    jagged[2] = new int[]{6, 7, 8, 9};
    
    System.out.println("===== 가변 길이 2차원 배열 =====")
    for (int[] row : jagged) {
    	System.out.println(Arrays.toString(jagged));
    }
    
    /*
    실행 결과
    ===== 2차원 배열 출력 =====
    1 2 3
    4 5 6
    7 8 9
    ===== 향상된 for문 =====
    1 2 3
    4 5 6
    7 8 9
    ===== 가변 길이 2차원 배열 =====
    [1, 2]
    [3, 4, 5]
    [6, 7, 8, 9]
    */
    ```
    
- 2차원 배열 활용
    
    ```java
    // 학생별 과목 점수 (3명의 학생, 4개의 과목)
    String[] students = {"철수", "영희", "민수"};
    String[] subjects = {"국어", "영어", "수학", "과학"};
    int[][] scores = {
    				{90, 85, 88, 92}, // 철수의 점수
    				{85, 90, 95, 88}, // 영희의 점수
    				{78, 82, 85, 90} // 민수의 점수
    };
    
    // 성적표 출력
    System.out.println("===== 성적표 출력 =====");
    System.out.print("이름\t");
    for (String subject : subjects) {
    	System.out.print(subject + "\t");
    }
    System.out.println("총점\t평균");
    System.out.println("-".repeat(50));
    
    // 각 학생의 성적 출력
    for (int i = 0; i < students.length; i++) {
    	System.out.print(students[i] + "\t");
    	int sum = 0;
    	for (int j = 0; j < scores[i].length; j++) {
    		System.out.print(scores[i][j] + "\t");
    		sum += scores[i][j];
    	}
    	double avg = (double) sum / scores[i].length;
    	System.out.print(sum + "\t" + avg);
    	System.out.println();
    }
    
    /* 
    출력 결과
    ===== 성적표 출력 =====
    이름	국어	영어	수학	과학	총점	평균
    --------------------------------------------------
    철수	90	85	88	92	355	88.75
    영희	85	90	95	88	358	89.5
    민수	78	82	85	90	335	83.75
    */
    ```
    

## 가변 길이 매개변수

- 메서드의 매개변수 개수를 유동적으로 받을 수 있는 기능이다.
- `타입... 변수명` 형식으로 선언하며, 내부적으로는 배열로 처리된다.
- 한 메서드에 하나만 선언이 가능하며, 마지막 위치에 와야한다.
- 예제
    
    ```java
    public class VarArgsExample {
    	
    	// 가변 길이 매개변수를 받는 메서드
    	public static int sum(int... numbers) {
    		int total = 0;
    		for (int num : numbers) {
    			total += num;
    		}
    		return total;
    	}
    	
    	// 일반 매개변수와 가변 길이 매개변수를 함께 사용
    	public static void printInfo(String name, int... scores) {
    		System.out.println(name + "의 점수: ");
    		for (int score : scores) {
    			System.out.print(score + " ");
    		}
    		System.out.println("(총 " + scores.length + "과목)");
    	}
    	
    	public static void main(String[] args) {
    		// 다양한 개수의 인수 전달 가능
    		System.out.println("sum(1, 2) = " + sum(1, 2));
    		System.out.println("sum(1, 2, 3) = " + sum(1, 2, 3));
    		System.out.println("sum(1, 2, 3, 4, 5) = " + sum(1, 2, 3, 4, 5));
    		System.out.println("sum() = " + sum()); // 인자 없이도 호출 가능
    		
    		// 배열을 직접 전달하는 것도 가능
    		int[] arr = {10, 20, 30};
    		System.out.println("sum(arr) = " + sum(arr));
    		
    		System.out.println();
    		printInfo("철수", 90, 85, 88);
    		printInfo("영희", 95, 92);
    	}
    }
    
    /*
    실행 결과
    sum(1, 2) = 3
    sum(1, 2, 3) = 6
    sum(1, 2, 3, 4, 5) = 15
    sum() = 0
    sum(arr) = 60
    
    철수의 점수: 90 85 88 (총 3과목)
    영희의 점수: 95 92 (총 2과목)
    */
    ```
    

---

# 객체지향 기초

## 객체지향 프로그래밍이란?

- OOP(Object-Oriented Programming)라고 하며, 컴퓨터 프로그래밍의 패러다임 중 하나이다.
- 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 **“객체”들의 모임**으로 보는 것으로, 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.
- 객체란, 세상의 모든 사물을 단순하게 추상화하면 속성(데이터)과 기능(메서드) 딱 두 가지로 설명할 수 있다.
- 현실 세계의 사물이나 개념을 객체로 모델링하고, 객체들 간의 상호작용을 통해 프로그램을 구성하는 방식이다.

### 절차지향 프로그래밍과 객체지향 프로그래밍의 차이

- **절차 지향 프로그래밍**
    - 이름 그대로 절차를 지향한다. 쉽게 이야기해서 실행 순서를 중요하게 생각하는 방식이다.
    - 프로그램의 흐름을 순차적으로 따르며 처리하는 방식이다. 즉, **“어떻게”** 를 중심으로 프로그래밍 한다.
- **객체 지향 프로그래밍**
    - 이름 그대로 객체를 지향한다. 쉽게 이야기해서 객체를 중요하게 생각하는 방식이다.
    - 실제 세계의 사물이나 사건을 객체로 보고, 객체들 간 상호작용을 중심으로 프로그래밍하는 방식이다. 즉, **“무엇을”** 을 중심으로 프로그래밍 한다.
- **둘의 중요한 차이**
    - 절차 지향은 데이터와 해당 데이터에 대한 처리 방식이 분리되어 있다.
    - 객체 지향은 데이터와 그 데이터에 대한 행동(메서드)이 하나의 ‘객체’ 안에 포함되어 있다.

## 클래스와 객체

- 흔히 클래스는 설계도, 객체/인스턴스는 설계도를 보고 실제로 만든 것으로 주로 비유한다.

| 개념 | 설명 | 비유 |
| --- | --- | --- |
| 클래스(Class) | 객체를 만들기 위한 설계도 | 붕어빵 틀, 설계 도면 |
| 객체(Object) | 클래스로부터 만들어진 실체 | 붕어빵, 실제 건물 |
| 인스턴스(Instance) | 메모리에 생성된 객체 | 구체적인 실체 |
| 참조 변수(Reference Variable) | 인스턴스를 가리키는 변수 | 리모컨, 이름표 |
- 참조되지 않는 인스턴스는 GC(Garbage Collection)에 의해 메모리에서 제거된다.
- 클래스 선언 규칙
    
    ```java
    [접근제어자] class 클래스이름 {
    	필드;
    	
    	생성자;
    	
    	메서드;
    }
    ```
    
    - 첫 문자는 숫자로 시작할 수 없고, 문자 혹은 ‘_’, ‘$’의 특수문자로 시작해야 한다.
    - 첫 문자를 제외하면, 숫자도 포함될 수 있다.
    - 자바의 예약어를 사용할 수 없고, 대소문자를 구분한다.
    - 길이에는 제한이 없지만, 공백은 포함할 수 없다.
    - 관례적으로 클래스명은 대문자로 시작하며, CamelCase를 사용한다.
- main 메서드가 없는 클래스는 실행되지 않으며, 다른 클래스에서 사용하기 위한 클래스이다.
- 객체를 생성하기 위한 방법은 3가지가 있다.
    - **new 연산자와 생성자** 사용 (가장 보편적이고, 많이 사용한다.)
    - 클래스 로더를 이용하는 방법
    - 메모리에 있는 인스턴스를 복제(clone)하는 방법
- 객체 생성 예제
    
    ```java
    public class VendingMachine {
    	// 필드
    	String product;
    	int price;
    	
    	// 메서드
    	public String pushProductButton(int menuId) {
    		if (menuId == 1) return "콜라";
    		else if (menuId == 2) return "사이다";
    		else if (menuId == 3) return "환타";
    		else return "없는 상품";
    	}
    }
    
    public class VendingMachineMain {
    	public static void main(String[] args) {
    		// 인스턴스 생성
    		VendingMachine vm1 = new VendingMachine();
    		VendingMachine vm2 = new VendingMachine();
    		
    		// 메서드 호출(메시지 전송)
    		String product = vm1.pushProductButton(1);
    		System.out.println("선택한 상품: " + product);
    		
    		// 자판기를 5개 만들고 싶다면?
    		VendingMachine[] machines = new VendingMachine[5];
    		for (int i = 0; i < 5; i++) {
    			machines[i] = new VendingMachine();
    		}
    	}
    }
    ```
    

## 필드(Field)

- 클래스가 가지는 속성을 필드라 하며, 클래스 내의 인스턴스 필드는 멤버 변수라고도 한다.
- 객체의 상태 정보를 저장한다.
- 필드 선언 (`[]`로 된 부분은 선택적으로 넣는 부분)
    
    ```java
    [접근제한자] [static] [final] 타입 필드명 [= 초기값];
    ```
    
    - `static`을 붙이게 되면 클래스 변수로 사용이 가능하다. (객체 생성 없이 접근 가능)
    - `final`을 붙이는 경우 한 번 초기화하면 변경이 불가능하다.
- 필드의 기본값
    - 정수형(byte, short, int, long)의 기본값: 0
    - 실수형(float, double)의 기본값: 0.0
    - 문자형(char)의 기본값: ‘\0’ (공백)
    - 논리형(boolean)의 기본값: false
    - 참조형(클래스, 배열, String 등)의 기본값: null
- 필드 예제
    
    ```java
    public class Person {
    	// 인스턴스 필드(멤버 변수)
    	String name;
    	int age;
    	String address = "서울";
    	
    	// 클래스 필드(static) // 객체 생성 없이도 접근 가능
    	static int count = 0;
    	
    	// 상수 (static final)
    	static final int MAX_SIZE = 150;
    }
    ```
    

## 접근제어자

- 접근 제어자를 사용하면 해당 클래스의 외부에서 특정 필드나 메서드에 접근하는 것을 허용하거나 제한할 수 있다.
- 종류
    - `private`: 모든 외부 호출을 막는다.
    - `default`(package-private): 같은 패키지 안에서 호출은 허용한다.
    - `protected`: 같은 패키지 안에서 호출은 허용한다. 패키지가 달라도 상속 관계의 호출은 허용한다.
    - `public`: 모든 외부 호출을 허용한다.
- 순서대로 `private`이 접근을 가장 많이 차단하고, `public`이 가장 많이 허용한다.
- 접근 제어자의 핵심은 속성과 기능을 외부로부터 숨기는 것이다.
    - `private`은 나의 클래스 안으로 속성과 기능을 숨길 때 사용하고, **외부 클래스**에서 해당 기능을 호출할 수 없다.
    - `default`는 나의 패키지 안으로 속성과 기능을 숨길 때 사용하고, **외부 패키지**에서 해당 기능을 호출할 수 없다.
    - `protected`는 상속 관계로 속성과 기능을 숨길 때 사용하고, **외부 패키지**나 **상속 관계**가 아닌 곳에서 해당 기능을 호출할 수 없다.
    - `public`은 기능을 숨기지 않고 **어디서든** 호출할 수 있게 공개한다.
- 예제
    
    ```java
    package access.parent;
    
    public class Parent {
    	public int publicValue;
    	protected int protectedValue;
    	int defaultValue;
    	private int privateValue;
    	
    	public void publicMethod() {
    		System.out.println("Parrent.publicMethod");
    	}
    	
    	protected void protectedMethod() {
    		System.out.println("Parent.protectedMethod");
    	}
    	
    	void defaultMethod() {
    		System.out.println("Parent.defaultMethod");
    	}
    	
    	private void privateMethod() {
    		System.out.println("Parent.privateMethod");
    	}
    	
    	public void printParent() {
    		System.out.println("==Parent 메서드 안==");
    		System.out.println("publicValue = " + publicValue);
    		System.out.println("protectedValue = " + protectedValue);
    		System.out.println("defaultValue = " + defaultValue); // 부모 메서드 안에서 접근 가능
    		System.out.println("privateValue = " + privateValue); // 부모 메서드 안에서 접근 가능
    		
    		// 부모 메서드 안에서 모두 접근 가능
    		defaultMethod();
    		privateMethod();
    	}
    }
    ```
    
    ```java
    package access.child;
    
    import extends1.access.parent.Parent;
    
    public class Child extends Parent {
    	public void call() {
    		publicValue = 1;
    		protectedValue = 1;   // 상속 관계 or 같은 패키지
    		// defaultValue = 1;   // 다른 패키지 접근 불가, 컴파일 오류
    		// privateValue = 1;   // 접근 불가, 컴파일 오류
    		
    		publicMethod();
    		protectedMethod();   // 상속 관계 or 같은 패키지
    		// defaultMethod();   // 다른 패지지 접근 불가, 컴파일 오류
    		// privateMethod();   // 접근 불가, 컴파일 오류
    		
    		printParent();
    	}
    }
    ```
    
    ```java
    package access;
    
    import access.child.Child;
    
    public class AccessMain {
    	public static void main(String[] args) {
    		Child child = new Child();
    		child.call()
    	}
    }
    
    /*
    실행 결과
    Parent.publicMethod
    Parent.protectedMethod
    ==Parent 메서드 안==
    publicValue = 1
    protectedValue = 1
    defaultValue = 0
    privateValue = 0
    Parent.defaultMethod
    Parent.privateMethod
    */
    ```
    

## 메서드

- 하나의 객체는 메시지를 전송함으로써 다른 객체에 접근한다.
- 객체의 행동을 유발하는 행위를 가리켜 **메시지-전송**이라 한다.
- 메시지-전송 매커니즘은 객체가 다른 객체에 접근할 수 있는 유일한 방법이다.
- 메서드 선언
    
    ```java
    [접근제한자] [static] 반환타입 메서드명(매개변수) {
    	//메서드 본문
    	return 반환값; // 반환타입이 void가 아닌 경우
    }
    ```
    
    - 반환타입을 `void`로 지정할 경우 반환값이 없기 때문에 `return` 문(반환값)은 없어도 된다.
    - `static`을 붙이게 되면 클래스 메서드로 사용이 가능하다. (객체 생성 없이 호출 가능)
- 다양한 메서드 형태
    
    ```java
    public class Calculator {
    	// 1. 매개변수 X, 반환값 X
    	public void printInfo() {
    		System.out.println("계산기 v1.0");
    	}
    	
    	// 2. 매개변수 O, 반환값 X
    	public void printNumber(int number) {
    		System.out.println("숫자: " + number);
    	}
    	
    	// 3. 매개변수 X, 반환값 O
    	public String getVersion() {
    		return "v1.0";
    	}
    	
    	// 4. 매개변수 O, 반환값 O
    	public int add(int a, int b) {
    		return a + b;
    	}
    	
    	// 5. 매개변수가 여러 개 있는 경우
    	public double calculate(double a, double b, String operator) {
    		switch (operator) {
    			case "+": return a + b;
    			case "-": return a - b;
    			case "*": return a * b;
    			case "/": return a / b;
    			case "%": return a % b;
    			default: return 0;
    		}
    	}
    	
    	// 6. static 메서드
    	public static String information() {
    		return "계산기입니다.";
    	}
    }
    ```
    
- 메서드 호출
    
    ```java
    public class CalculatorMain {
    	public static void main(String[] args) {
    		Calculator.information(); // static 메서드는 객체 생성 없이 클래스를 통해 호출 가능
    		
    		Calculator calc = new Calculator();
    		
    		// 메서드 호출
    		calc.printInfo(); // 매개변수가 없고, 반환값이 없는 메서드
    		calc.printNumber(100); // 매개변수가 있고, 반환값이 없는 메서드
    		
    		String version = calc.getVersion(); // 매개변수가 없고, 반환타입이 String인 메서드
    		int result = calc.add(10, 20); // 매개변수가 있고, 반환타입이 int인 메서드
    		
    		// 매개변수가 여러 개, 반환타입이 double인 메서드
    		double result2 = calc.calculate(10.5, 3.2, "*");
    		
    		System.out.println("version = " + version);
    		System.out.println("10 + 20 = " + result);
    		System.out.println("10.5 * 3.2 = " + result2);
    	}
    }
    
    /*
    실행 결과
    계산기입니다.
    계산기 v1.0
    숫자: 100
    version = v1.0
    10 + 20 = 30
    10.5 * 3.2 = 33.6
    */
    ```
    
- 매개변수와 전달인자의 차이
    - 매개변수(parameter) : 메서드 정의 시 선언하는 변수이다.
    - 전달인자(argument) : 메서드 호출 시 전달하는 실제 값이다.
