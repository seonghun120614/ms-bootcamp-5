# 스트림 이해하기

## 스트림의 개념과 필요성

- **스트림(Stream)**은 데이터의 연속적인 흐름을 추상화한 API이다.
- 데이터 컬렉션을 더 간결하고 직관적인 방식으로 처리할 수 있게 해주는 강력한 도구이다.
- 기존 **for 루프**는 데이터를 **어떻게 처리할지(How)**를 직접 작성해야 했지만,
**스트림**은 데이터를 **무엇(What)을 할 건지**만 선언하면 된다. → 내부적으로 최적화된 방식으로 처리
- **필요성**
    - **더 나은 데이터 처리**: 컬렉션의 데이터를 더 효율적으로 처리한다.
    - **함수형 프로그래밍 지원**: 람다식과 함께 사용하여 간결한 코드를 작성할 수 있다.
    - **병렬 처리 용이성**: 멀티코어 프로세서를 쉽게 활용할 수 있다.

## 스트림과 컬렉션의 차이점

| **구분** | **컬렉션(Collection)** | **스트림(Stream)** |
| --- | --- | --- |
| **데이터 저장** | 모든 데이터를 메모리에 저장 | 데이터를 저장하지 않고 처리 |
| **처리 방식** | 외부 반복(External Iteration) | 내부 반복(Internal Iteration) |
| **데이터 계산** | 즉시 계산 | 지연 계산(Lazy Evaluation) |
| **재사용** | 여러 번 사용 가능 | 한 번만 사용 가능 |
| **병렬 처리** | 직접 구현 필요 | parallelStream()으로 간단히 처리 |

# 스트림 생성과 활용

## 다양한 소스에서 스트림 생성

**컬렉션에서 스트림 생성**

```java
public class StreamCreation {
	public static void main(String[] args) {
		// List에서 스트림 생성
		List<String> list = Arrays.asList("Java", "Python", "JavaScript");
		Stream<String> streamFromList = list.stream();
		
		// Set에서 스트림 생성
		Set<Integer> set = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
		Stream<Integer> streamFromSet = set.stream();
	}
}
```

**배열에서 스트림 생성**

```java
// 배열에서 스트림 생성
String[] array = {"Spring", "Summer", "Fall", "Winter"};
Stream<String> streamFromArray = Arrays.stream(array);

// 부분 배열에서 스트림 생성
Stream<String> partialStream = Arrays.stream(array, 1, 3); // Summer, Fall
```

**스트림의 정적 메서드 사용**

```java
// Stream.of() 사용
Stream<Integer> numberStream = Stream.of(1, 2, 3, 4, 5);

// Stream.iterate() - 무한 스트림 생성
Stream<Integer> iterateStream = Stream.iterate(0, n -> n + 2)
				.limit(10); // 0, 2, 4, 6, ... , 18

// Stream.generate() - 무한 스트림 생성
Stream<Double> randomStream = Stream.generate(Math::random)
				.limit(5);
```

**파일에서 스트림 생성**

```java
try {
	Stream<String> lines = Files.lines(Paths.get("data.txt"));
	lines.forEach(System.out::println);
	lines.close(); // 파일 스트림은 반드시 닫아야 한다.
} catch (IOException e) {
	e.printStackTrace();
}
```

## 중간 연산과 최종 연산

<img width="943" height="267" alt="Image" src="https://github.com/user-attachments/assets/b319ceef-9160-48eb-a46d-4f0e1c497697" />

- **스트림 연산의 구분**
    - **중간 연산(Intermediate Operations)**
        - 새로운 스트림을 반환하며 연쇄 가능하다.
        - 지연 연산으로, 데이터가 즉시 처리되지 않고 최종 연산이 호출될 때만 실행된다.
    - **최종 연산(Terminal Operations)**
        - 결과를 반환하며 스트림을 소비한다.
        - `collect(Collectors.toList())`를 사용하면 가변 리스트 반환
        - `toList()`를 사용하면 불변 리스트 반환

**중간 연산 예시**

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David", "Eve");

List<String> result = names.stream()        
				.filter(name -> name.length() > 3)  // 중간 연산: 필터링
				.map(String::toUpperCase)           // 중간 연산: 변환
				.sorted()                           // 중간 연산: 정렬
				.collect(Collectors.toList());      // 최종 연산: 수집

System.out.println(result); // [ALICE, CHARLIE, DAVID]
```

# 데이터 필터링과 변환

## 필터링: filter, distinct

**filter 메서드**

```java
public class FilterExample {
	public static void main(String[] args) {
		List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
		
		// 짝수만 필터링
		List<Integer> evenNumbers = numbers.stream()
						.filter(n -> n % 2 == 0)
						.collect(Collectors.toList());
		
		System.out.println("짝수: " + evenNumbers); // [2, 4, 6, 8, 10]
		
		// 복합 조건 필터링
		List<Integer> filtered = numbers.stream()
						.filter(n -> n > 3)
						.filter(n -> n < 8)
						.collect(Collectors.toList());
		
		System.out.println("3 < n < 8: " + filtered); // [4, 5, 6, 7]
	}
}
```

**distinct 메서드**

```java
public class DistinctExample {
	public static void main(String[] args) {
		List<String> words = Arrays.asList(
						"Apple", "Banana", "Cherry", "Apple", "Cherry", "Date");
		
		// 중복 제거
		List<String> uniqueWords = words.stream()
						.distinct()
						.collect(Collectors.toList());
		
		System.out.println("고유한 단어: " + uniqueWords);
		// [Apple, Banana, Cherry, Date]
		
		// 필터링과 중복 제거 조합
		List<String> result = words.stream()
						.filter(word -> word.length() > 5)
						.distinct()
						.collect(Collectors.toList());
		
		System.out.println("5자 초과 고유 단어: " + result); // [Banana, Cherry]
	}
}
```

## 변환: map, flatMap

**map 메서드 (변환)**

```java
public class MapExample {
	public static void main(String[] args) {
		List<String> names = Arrays.asList("alice", "bob", "charlie");
		
		// 대문자로 변환
		List<String> upperNames = names.stream()
						.map(String::toUpperCase)
						.collect(Collectors.toList());
		
		System.out.println(upperNames); // [ALICE, BOB, CHARLIE]
		
		// 길이로 변환
		List<Integer> lengths = names.stream()
						.map(String::length)
						.collect(Collectors.toList());
		
		System.out.println(lengths); // [5, 3, 7]
	}
}
```

**flatMap 메서드 (평탄화)**

<img width="931" height="415" alt="Image" src="https://github.com/user-attachments/assets/06816183-d95b-4eb0-9378-7c913875d2e1" />

```java
public class FlatMapExample {
	public static void main(String[] args) {
		// 중첩된 리스트를 평탄화
		List<List<String>> nestedList = Arrays.asList(
				Arrays.asList("Apple", "Banana"),
				Arrays.asList("Cherry", "Date"),
				Arrays.asList("Elderberry", "Fig")
		);
		
		List<String> flatList = nestedList.stream()
						.flatMap(Collection::stream)
						.collect(Collectors.toList());
		
		System.out.println(flatList);
		// [Apple, Banana, Cherry, Date, Elderberry, Fig]
		
		// 문자열을 문자 스트림으로 변환
		List<String> words = Arrays.asList("Hello", "World");
		List<String> letters = words.stream()
						.flatMap(word -> Arrays.stream(word.split("")))
						.distinct()
						.collect(Collectors.toList());
		
		System.out.println(letters); // [H, e, l, o, W, r, d]
	}
}
```

# 정렬과 순회

## 정렬: sorted

```java
public class SortExample {
	public static void main(String[] args) {
		List<String> fruits = Arrays.asList("Banana", "Apple", "Cherry", "Date");
		
		// 자연 순서 정렬 (오름차순)
		List<String> sortedAsc = fruits.stream()
						.sorted()
						.collect(Collectors.toList());
		
		System.out.println("오름차순: " + sortedAsc);
		//[Apple, Banana, Cherry, Date]
		
		// 역순 정렬 (내림차순)
		List<String> sortedDesc = fruits.stream()
						.sorted(Comparator.reverseOrder())
						.collect(Collectors.toList());
		
		System.out.println("내림차순: " + sortedDesc);
		// [Date, Cherry, Banana, Apple]
		
		// 길이 기준 정렬
		List<String> sortedByLength = fruits.stream()
						.sorted(Comparator.comparingInt(String::length))
						.collect(Collectors.toList());
		
		System.out.println("길이순: " + sortedByLength);
		// [Date, Apple, Banana, Cherry]
		
		// 기본 타입 정렬
		int[] intArr = {200, 3, 4, 7, 88, 99};
		Arrays.stream(intArr)
						//.sorted(Comparator.reverseOrder()) // 기본타입에는 적용되지 않는다.
						.boxed() // Integer 타입으로 형변환
						.sorted(Comparator.reverseOrder())
						.forEach(n -> System.out.println(n + "\t"));
						// 200 99 88 7 4 3
	}
}
```

## 순회: forEach, peek

```java
public class TraversalExample {
	public static void main(String[] args) {
		List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
		
		// forEach - 최종 연산
		System.out.println("=== forEach 예시 ===");
		numbers.stream()
						.forEach(n -> System.out.println("Number: " + n));
		
		// peek - 중간 연산 (디버깅용)
		System.out.println("\n=== peek 예시 ===");
		List<Integer> doubled = numbers.stream()
						.peek(n -> System.out.println("원본: " + n))
						.map(n -> n * 2)
						.peek(n -> System.out.println("두 배: " + n))
						.collect(Collectors.toList());
		
		System.out.println("최종 결과: " + doubled);
	}
}
```

# 매칭과 검색

## 조건 매칭: allMatch, anyMatch, noneMatch

```java
public class MatchingExample {
	public static void main(String[] args) {
		List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
		
		// allMatch - 모든 요소가 조건 만족
		boolean allPositive = numbers.stream()
						.allMatch(n -> n > 0);
		System.out.println("모두 양수? " + allPositive); // true
		
		// anyMatch - 하나라도 조건 만족
		boolean hasEven = numbers.stream()
						.anyMatch(n -> n % 2 == 0);
		System.out.println("짝수 존재? " + hasEven); // true
		
		// noneMatch - 모든 요소가 조건 불만족
		boolean noNegative = numbers.stream()
						.noneMatch(n -> n < 0);
		System.out.println("음수 없음? " + noNegative); // true
	}
}
```

## 요소 검색: findFirst, findAny

```java
public class FindExample {
	public static void main(String[] args) {
		List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
		
		// findFirst - 첫 번째 요소
		Optional<String> first = names.stream()
						.filter(name -> name.startsWith("C"))
						.findFirst();
		
		first.ifPresent(name -> System.out.println("C로 시작하는 첫 이름: " + name));
		// Charlie
		
		// findAny - 아무 요소나 (병렬 처리 시 유용)
		Optional<String> any = names.parallelStream()
						.filter(name -> name.length() > 3)
						.findAny();
		
		any.ifPresent(name -> System.out.println("3자 초과 아무 이름: " + name));
	}
}
```

# 집계 연산

## 기본 집계: count, min, max

```java
public class AggregateExample {
	public static void main(String[] args) {
		List<Integer> numbers = Arrays.asList(3, 7, 2, 9, 1, 5, 8, 4, 6);
		
		// count - 요소 개수
		long count = numbers.stream().count();
		System.out.println("개수: " + count); // 9
		
		// min - 최솟값
		Optional<Integer> min = numbers.stream()
						.min(Integer::compareTo);
		min.ifPresent(n -> System.out.println("최솟값: " + n)); // 1
		
		// max - 최댓값
		Optional<Integer> max = numbers.stream()
						.max(Integer::compareTo);
		max.ifPresent(n -> System.out.println("최댓값: " + n)); // 9
```

## 숫자 스트림 집계

```java
public class NumericStreamExample {
	public static void main(String[] args) {
		List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
		
		// IntStream으로 변환하여 집계
		int sum = numbers.stream()
						.mapToInt(Integer::intValue)
						.sum();
		System.out.println("합계: " + sum); // 15
		
		double average = numbers.stream()
						.mapToInt(Integer::intValue)
						.average()
						.orElse(0.0);
		System.out.println("평균: " + average); // 3.0
		
		// 통계 정보 한 번에 얻기
		IntSummaryStatistics stats = numbers.stream()
						.mapToInt(Integer::intValue)
						.summaryStatistics();
		
		System.out.println("통계: " + stats);
		// IntSummaryStatistics{count=5, sum=15, min=1, average=3.0, max=5}
	}
}
```

# 리듀싱과 수집

## reduce 연산

```java
public class ReduceExample {
	public static void main(String[] args) {
		List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
		
		// 합계 구하기 (초기값 있음)
		int sum = numbers.stream()
						.reduce(0, (a, b) -> a + b);
		System.out.println("합계: " + sum); // 15
		
		// 합계 구하기 (메서드 참조)
		int sum2 = numbers.stream()
						.reduce(0, Integer::sum);
		System.out.println("합계2: " + sum2); // 15
		
		// 최댓값 구하기 (초기값 없음)
		Optional<Integer> max = numbers.stream()
						.reduce(Integer::max);
		max.ifPresent(n -> System.out.println("최댓값: " + n)); // 5
		
		// 문자열 연결
		List<String> words = Arrays.asList("Hello", " ", "World", "!");
		String sentence = words.stream()
						.reduce("", String::concat);
		System.out.println(sentence); // Hello World!
	}
}
```

## Collectors를 이용한 수집

```java
public class CollectorsExample {
	public static void main(String[] args) {
		List<Student> students = Arrays.asList(
			new Student("Alice", 85, "CS"),
			new Student("Bob", 92, "Math"),
			new Student("Charlie", 78, "CS"),
			new Student("David", 88, "Physics"),
			new Student("Eve", 95, "Math")
		);
		
		// toList로 수집
		List<String> names = students.stream()
						.map(Student::getName)
						.collect(Collectors.toList());
		
		// toSet으로 수집
		Set<String> departments = students.stream()
						.map(Student::getDepartment)
						.collect(Collectors.toSet());
		
		// toMap으로 수집
		Map<String, Integer> nameToScore = students.stream()
						.collect(Collectors.toMap(
								Student::getName,
								Student::getScore
						));
		
		// joining으로 문자열 결합
		String allNames = students.stream()
						.map(Student::getName)
						.collect(Collectors.joining(", "));
		System.out.println("모든 학생: " + allNames);
		// 모든 학생: Alice, Bob, Charlie, David, Eve
	}
	
	static class Student {
		private String name;
		private int score;
		private String department;
		
		public Student(String name, int score, String department) {
			this.name = name;
			this.score = score;
			this.department = department;
		}
		
		// Getter
		public String getName() { return name; }
		public int getScore() { return score; }
		public String getDepartment() { return department; }
	}
}
```

# 그룹화와 분할

## groupingBy를 이용한 그룹화

```java
public class GroupingExample {
	public static void main(String[] args) {
		List<Employee> employees = Arrays.asList(
			new Employee("Alice", "IT", 5000),
			new Employee("Bob", "HR", 4000),
			new Employee("Charlie", "IT", 5500),
			new Employee("David", "HR", 4500),
			new Employee("Eve", "Sales", 4800)
		);
		
		// 부서별 그룹화
		Map<String, List<Employee>> byDepartment = employees.stream()
						.collect(Collectors.groupingBy(Employee::getDepartment));
		
		System.out.println("부서별 직원: ");
		byDepartment.forEach((dept, emps) -> {
				System.out.println(dept + ": " +
						emps.stream().map(Employee::getName).collect(Collectors.toList()));
		});
		
		// 부서별 평균 급여
		Map<String, Double> avgSalaryByDept = employees.stream()
						.collect(Collectors.groupingBy(
								Employee::getDepartment,
								Collectors.averagingDouble(Employee::getSalary)
						));
		
		System.out.println("\n부서별 평균 급여: ");
		avgSalaryByDept.forEach((dept, avg) -> System.out.println(dept + ": " + avg));
		
		// 다단계 그룹화
		Map<String, Map<Boolean, List<Employee>>> complexGrouping = employees.stream()
						.collect(Collectors.groupingBy(
								Employee::getDepartment,
								Collectors.partitioningBy(e -> e.getSalary() > 4500)
						));
	}
	
	static class Employee {
		private String name;
		private String department;
		private double salary;
		
		public Employee(String name, String department, double salary) {
			this.name = name;
			this.department = department;
			this.salary = salary;
		}
		
		public String getName() { return name; }
		public String getDepartment() { return department; }
		public double getSalary() { return salary; }
	}
}
```

## partitioningBy를 이용한 분할

```java
public class PartitioningExample {
	public static void main(String[] args) {
		List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
		
		// 짝수와 홀수로 분할
		Map<Boolean, List<Integer>> evenOddPartition = numbers.stream()
						.collect(Collectors.partitioningBy(n -> n % 2 == 0));
		
		System.out.println("짝수: " + evenOddPartition.get(true)); // [2, 4, 6, 8, 10]
		System.out.println("홀수: " + evenOddPartition.get(false)); // [1, 3, 5, 7, 9]
		
		// 학생을 합격/불합격으로 분할
		List<Student> students = Arrays.asList(
			new Student("Alice", 85),
			new Student("Bob", 65),
			new Student("Charlie", 75),
			new Student("David", 55)
		);
		
		Map<Boolean, List<Student>> passFail = students.stream()
						.collect(Collectors.partitioningBy(s -> s.getScore() >= 70));
		
		System.out.println("\n합격자: ");
		passFail.get(true).forEach(s -> 
				System.out.println(s.getName() + ": " + s.getScore())
		);
		
		System.out.println("\n불합격자: ");
		passFail.get(false).forEach(s ->
				System.out.println(s.getName() + ": " + s.getScore())
		);
	}
	
	static class Student {
		private String name;
		private int score;
		
		public Student(String name, int score) {
			this.name = name;
			this.score = score;
		}
		
		public String getName() { return name; }
		public int getScore() { return score; }
	}
}
```

# 병렬 스트림

## 병렬 스트림의 동작 원리

- 병럴 스트림은 내부적으로 Fork/Join 프레임워크를 사용하여 작업을 여러 스레드에 분산시킨다.
- 큰 데이터셋 처리 시 성능이 향상되지만, 작은 데이터셋은 오히려 성능을 저하시킬 수 있다.

```java
public class ParallelStreamExample {
	public static void main(String[] args) {
		List<Integer> numbers = new ArrayList<>();
		for (int i = 1; i <= 1000000; i++) {
			numbers.add(i);
		}
		
		// 순차 스트림 처리 시간 측정
		long startTime = System.currentTimeMillis();
		long sum1 = numbers.stream()
						.mapToLong(Integer::longValue)
						.sum();
		long sequentialTime = System.currentTimeMillis() - startTime;
		
		// 병렬 스트림 처리 시간 측정
		startTime = System.currentTimeMillis();
		long sum2 = numbers.parallelStream()
						.mapToLong(Integer::longValue)
						.sum();
		
		long parallelTime = System.currentTimeMillis() - startTime;
		
		System.out.println("순차 처리 시간: " + sequentialTime + "ms");
		System.out.println("병렬 처리 시간: " + parallelTime + "ms");
		System.out.println("결과 동일: " + (sum1 == sum2));
	}
}
```

## 병렬 처리의 주의점

1. **스레드 오버헤드**: 작은 데이터셋에서는 오히려 성능이 저하된다.
2. **순서 보장 안됨**: 순서가 중요한 경우 사용에 주의해야 한다.
3. **스레드 안정성**: 공유 자원 접근 시 동기화가 필요하다.
4. **Boxing/Unboxing 비용**: 기본형 특화 스트림 사용을 권장한다.

```java
public class ParallelStreamCaution {
	public static void main(String[] args) {
		// 잘못된 예: 스레드 안전하지 않은 컬렉션
		List<Integer> list = new ArrayList<>();
		IntStream.range(0, 1000)
						.parallel()
						.forEach(list::add); // ConcurrentModificationException 가능성이 있어 위험
		
		// 올바른 예: 스레드 안전한 수집
		List<Integer> safeList = IntStream.range(0, 1000)
						.parallel()
						.boxed()
						.collect(Collectors.toList());
		
		System.out.println("안전한 리스트 크기: " + safeList.size());
	}
}
```
