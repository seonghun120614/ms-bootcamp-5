# 08/22 회고록
<br>
<br>

## 자바 난수 생성 방법

### 1. Math.random()
- `Math` 클래스의 **static 메서드**
- `0.0 이상 1.0 미만`의 double 값을 반환
- 원하는 범위: 곱하기(`*`)와 형 변환 사용

    ## 예시 코드
    ```java
    int num = (int)(Math.random() * 10) + 1; 
    // 1 ~ 10 사이의 정수 난수
    ```

### 2. Random 클래스

- 자바에서 난수를 생성할 수 있는 전용 클래스
- 다양한 타입의 난수를 생성할 수 있음 (`int`, `double`, `boolean` 등)
- 시드(Seed) 값을 지정할 수 있어 재현성 있는 난수 생성 가능


    ## 예시 코드
    ```java
    import java.util.Random;

    public class Main {
        public static void main(String[] args) {
            Random random = new Random();
            random.setSeed(System.currentTimeMillis()); // 시드 설정
            int num1 = random.nextInt(10) + 1; // 1 ~ 10 사이의 정수 난수
            double num2 = random.nextDouble(); // 0.0 이상 1.0 미만 실수 난수
            boolean flag = random.nextBoolean(); // true 또는 false 난수
        }
    }
    ```
<br>

---
- 두 방식의 단점
    - Math.random() : 내부적으로 단일 Random 객체를 공유 -> 여러 스레드가 동시에 쓰면 락(lock) 때문에 성능 저하.
    - new Random() : 스레드마다 직접 만들어 쓰면 락은 없지만, 시드 충돌 위험 & 관리 번거로움.

---
### 3. ThreadLocalRandom

- 각 스레드마다 독립적인 Random을 자동으로 관리해줌

```java
import java.util.concurrent.ThreadLocalRandom;

public class Example {
    public static void main(String[] args) {
        // 0 이상 100 미만의 난수
        int num = ThreadLocalRandom.current().nextInt(100);
        System.out.println(num);

        // 1 이상 45 이하의 난수 (로또 번호처럼)
        int lotto = ThreadLocalRandom.current().nextInt(1, 46);
        System.out.println(lotto);

        // double 난수
        double d = ThreadLocalRandom.current().nextDouble();
        System.out.println(d);
    }
}
```

<br>
<br>

##  메서드 오버로딩 (Method Overloading)

### 정의
- 같은 이름의 메서드를 여러 개 정의하는 것
- 단, **매개변수의 개수·타입·순서**가 달라야 한다.
- 반환형만 다르다고 오버로딩이 되지는 않는다.

### 특징
1. 메서드 이름은 같아야 한다.
2. 매개변수의 **개수/타입/순서**가 달라야 한다.
3. 반환형은 오버로딩 성립에 영향을 주지 않는다.
4. 컴파일 시점에 어떤 메서드가 실행될지 결정된다. (**정적 바인딩**)

### 예시 코드
```java
public class Printer {
    // 다양한 타입을 출력하는 print 메소드들
    public void print(int value) {
        System.out.println("정수: " + value);
    }

    public void print(double value) {
        System.out.println("실수: " + value);
    }

    public void print(String value) {
        System.out.println("문자열: " + value);
    }

    public void print(int x, int y) {
        System.out.println("좌표: (" + x + ", " + y + ")");
    }

    // 가변 매개변수
    public void print(String... values) {
        System.out.print("여러 문자열: ");
        for(String value : values) {
            System.out.print(value + " ");
        }
        System.out.println();
    }
}
```
<br>
<br>

## 생성자 

### 생성자란?
- 객체가 생성될 때 자동으로 호출되는 특별한 메소드
- 객체의 초기화를 담당
- 클래스 이름과 동일한 이름을 가짐
- 반환 타입이 없음 


### 기본 생성자
- 클래스에 생성자를 작성하지 않으면 컴파일러가 자동으로 기본 생성자(Default Constructor)를 추가
- 다른 생성자를 정의하면 기본 생성자는 자동 생성되지 않음
- ex) `Scanner` 클래스는 기본 생성자가 없고 `System.in` 등의 매개변수를 넣어야 함
```java
public class Book {
    String title;
    String author;
    int price;

    // 기본 생성자 (생략 가능)
    public Book() {
        System.out.println("Book 객체가 생성되었습니다.");
    }
}
```



## this 키워드

- this. 를 사용하여 현재 인스턴스를 가리키는 참조 변수를 지정할 수 있음
- this()를 이용하여 다른 생성자를 호출할 수 있으며, 생성자 중복 코드를 줄이는 데 사용됨
- this()는 생성자의 첫 번째 줄에서만 사용 가능


### 예제 1
```java
public class Book {
    String title;
    String author;
    int price;

    // 기본 생성자
    public Book() {
        this("제목없음", "작자미상", 0);
    }

    // 매개변수 1개
    public Book(String title) {
        this(title, "작자미상", 0);
    }

    // 매개변수 3개 (모든 필드 초기화)
    public Book(String title, String author, int price) {
        this.title = title;
        this.author = author;
        this.price = price;
    }

    public void displayInfo() {
        System.out.println("제목: " + title);
        System.out.println("저자: " + author);
        System.out.println("가격: " + price + "원");
        System.out.println("---");
    }
}
```

### 예제 2

```java
public class Person {
    private String name;
    private int age;
    private String address;

    // this를 사용한 필드 접근
    public Person(String name, int age) {
        this.name = name;  // this.name은 필드, name은 매개변수
        this.age = age;
    }

    // 메소드에서 this 사용
    public void introduce() {
        System.out.println("안녕하세요, 저는 " + this.name + "입니다.");
        System.out.println("나이는 " + this.age + "살입니다.");
    }

    // this를 반환하는 메소드 (메소드 체이닝)
    public Person setAddress(String address) {
        this.address = address;
        return this;  // 현재 객체를 반환
    }

    public Person setAge(int age) {
        this.age = age;
        return this;
    }

    // 다른 메소드 호출 시 this 사용 (선택적)
    public void displayAll() {
        this.introduce();  // this는 생략 가능
        System.out.println("주소: " + address);
    }
}
```
```java

// 사용 예제
public class PersonTest {
    public static void main(String[] args) {
        Person person = new Person("김철수", 25);

        // 메소드 체이닝
        person.setAddress("서울시 강남구")
              .setAge(26);

        person.displayAll();
    }
}
```
- 메소드 체이닝 : 객체의 메서드를 연속적으로 호출하는 방식
    - return 값이 객체여야함




## 패키지와 import

- 관련된 클래스들을 그룹화하는 디렉토리 구조
- 클래스의 충돌을 방지하고 관리를 용이하게 함
    - 동일한 이름의 클래스를 사용할 수 있게 됨
- 도메인 역순으로 작성하는 것이 관례 (예: com.company.project)
- 자바의 파일명은 패키지명.클래스명 ex) **com.company.project**.Test
- static import




## 자바 메모리 구조 & static 키워드

### 자바 메모리 구조
1. **Metaspace**
   - 클래스의 메타데이터(필드 정보, 메서드 정보, 바이트코드 등)가 저장되는 영역
   - Java 7까지는 PermGen(Permanent Generation)이 사용되었으나, Java 8부터는 **Metaspace**로 대체
   - JVM 내에서 고정메모리로 사용된 PermGen과 달리 OS가 직접 관리하여서 메모리관리가 용이해짐 
   - 메모리 용량으로 인한 OutOfMemoryError 문제 해결
   - 클래스 로딩 시, `.class` 파일의 정보가 Metaspace에 저장된다.

2. **Heap**
   - `new` 연산자로 생성되는 **모든 객체와 배열이 저장**되는 영역
   - **Garbage Collector(GC)** 에 의해 관리 → 더 이상 참조되지 않는 객체는 수거 대상
   - **static 필드도 Heap에 저장** (Java 8 이후 기준)
   - 프로그램 종료 시까지 유지되며 모든 인스턴스가 공유

3. **Stack**
   - 각 스레드마다 생성되는 영역
   - 메서드 호출 시 스택 프레임(Stack Frame) 이 쌓이고, 종료되면 제거
   - 매개변수, 지역 변수, 연산 중 임시 값 저장
   - 객체 자체는 Heap에 존재하고, Stack에는 그 객체를 가리키는 참조값만 저장

---

### 자바 프로그램 실행 과정의 메모리 사용 흐름
1. 프로그램 실행 시 클래스가 로딩되고, 메타데이터는 Metaspace에 저장된다.  
2. 객체가 생성되면 Heap에 인스턴스가 저장된다.  
3. static 필드는 클래스 로딩 시 **Heap**에 저장되고 전역적으로 공유된다.  
4. 메서드 실행 시 Stack에 스택 프레임이 생성되어 지역 변수·매개변수가 저장된다.  
5. 메서드 종료 시 스택 프레임은 제거되고, Heap의 객체는 참조가 사라지면 GC에 의해 제거된다.  

---

### 인스턴스 vs static 비교

- **인스턴스 필드**
  - 객체(인스턴스)에 속하며, `new`로 객체를 생성할 때마다 새로 만들어짐
  - Heap 영역의 인스턴스 내부에 저장되며, 각 객체마다 값이 다를 수 있음

- **static 필드**
  - 클래스에 속하며, 클래스가 로딩될 때 한 번만 메모리에 올라감
  - Heap 영역(Class 객체를 통해) 저장되고, 모든 객체가 동일한 값을 공유

- **인스턴스 메소드**
  - 객체 상태(필드 값)에 따라 동작하며, 반드시 객체를 생성해야 호출 가능
  - 호출 방법: `객체참조변수.메소드()`

- **static 메소드**
  - 특정 객체의 상태와 무관하게 클래스 차원에서 동작
  - 객체 생성 없이 `클래스명.메소드()` 로 호출 가능

---

### 8-4. static 키워드 정리
- **static 저장 위치**
  - Java 7 이전 → `PermGen` 영역 (Non-Heap)
  - Java 8 이후 → static 변수는 **Heap**에 저장, 클래스 메타데이터는 **Metaspace**에 저장
- **초보자가 기억해야 할 메모리 개념**
  1. `new` 연산자를 사용할 때마다 메모리에 인스턴스가 생성된다.
  2. 인스턴스는 참조가 사라지면 GC에 의해 수거된다.
  3. `static` 필드는 클래스 로딩 시 단 한 번 메모리에 올라간다.
  4. 인스턴스 메서드는 객체를 생성하고 참조 변수를 통해 호출한다.
  5. 클래스 메서드(static 메서드)는 `클래스명.메소드명()` 으로 호출한다.
  6. 메서드 안의 지역 변수는 실행 시 생성, 종료 시 제거된다.

---

### 8-5. static 필드와 메소드 예제
```java
public class Student {
    // 인스턴스 필드
    String name;
    int score;

    // 클래스 필드 (모든 인스턴스가 공유)
    static int totalStudents = 0;
    static int totalScore = 0;

    // 생성자
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
        totalStudents++;
        totalScore += score;
    }

    // 인스턴스 메소드
    public void displayInfo() {
        System.out.println(name + ": " + score + "점");
    }

    // 클래스 메소드
    public static double getAverage() {
        if(totalStudents == 0) return 0;
        return (double)totalScore / totalStudents;
    }

    public static void displayStatistics() {
        System.out.println("전체 학생 수: " + totalStudents);
        System.out.println("전체 점수 합: " + totalScore);
        System.out.println("평균 점수: " + getAverage());
    }
}
```



## 실습 
 
### 로또 프로그램
```java
import java.util.Arrays;
import java.util.concurrent.ThreadLocalRandom;

public class Lotto {
    boolean[] balls = new boolean[45];

    public int draw() {
        int num;
        while (true) {
            num = ThreadLocalRandom.current().nextInt(1, 46);
            if (!balls[num - 1]) {
                balls[num - 1] = true;
                break;
            }
        }
        return num;
    }

    public static void main(String[] args) {
        Lotto lotto = new Lotto();
        int[] answer = new int[6];
        for (int i = 0; i < 6; i++) {
            answer[i] = lotto.draw();
            System.out.printf("%d번째 당첨 번호 : %d%n", i + 1, answer[i]);
        }
        System.out.println("결과 : " + Arrays.toString(answer));
    }
}

```