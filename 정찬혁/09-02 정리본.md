# 09-02

# API

모든 API를 외울 수는 없다. 필요한 상황에 구글링과 공식 문서를 찾아보는 것이 더 효율적이다.

### 정렬 / Comparable과 Comparator

- Comparable 인터페이스 : 객체의 기본 정렬 기준을 정의 - compareTo() 메소드 구현
- Comparator 인터페이스 : 별도의 정렬 기준을 정의 - compare() 메소드 구현

**Comparable 예제**

```java
package day10;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Person implements Comparable<Person> {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Person other) {
        return this.age - other.age; // 나이를 기준으로 오름차순 정렬
    }

    @Override
    public String toString() {
        return name + ": " + age;
    }

    public static void main(String[] args) {
        List<Person> people = new ArrayList<>();
        people.add(new Person("Alice", 32));
        people.add(new Person("Bob", 24));
        people.add(new Person("Charlie", 28));

        Collections.sort(people); // Comparable 사용한 정렬 /////sort()

        for (Person person : people) {
            System.out.println(person);
        }
    }
}
```

- Collections.sort();
- sort() → compareTo() 오버라이드 호출

**Comparator 예제**

Student 클래스

```java
package day10.comparatorExam;

public class Student implements Comparable<Student> {
    private String name;
    private int score;

    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }

    // 기본 정렬: 점수 기준 내림차순
    @Override
    public int compareTo(Student other) {
        return other.score - this.score; // 내림차순
        // return this.score - other.score; // 오름차순
    }

    @Override
    public String toString() {
        return name + "(" + score + ")";
    }

    // getter 메소드들
    public String getName() { return name; }
    public int getScore() { return score; }
}
```

ComparatorExample 클래스

```java
package day10.comparatorExam;
import java.util.*;

public class ComparatorExample {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student("김철수", 85));
        students.add(new Student("이영희", 92));
        students.add(new Student("박민수", 78));
        students.add(new Student("정수진", 92));

        // 1. Comparable을 이용한 기본 정렬 (점수 내림차순)
        Collections.sort(students);
        System.out.println("점수 내림차순: " + students);

        // 2. Comparator를 이용한 이름순 정렬
        //Comparator를 전달하면 compare() 메소드 호출 
        Collections.sort(students, new Comparator<Student>() { 
            @Override
            public int compare(Student s1, Student s2) {
	                return s1.getName().compareTo(s2.getName()); //오름차순 정렬
            }
        });
        System.out.println("이름 오름차순: " + students);

        // 3. Lambda를 이용한 간단한 표현 (Java 8+)
        Collections.sort(students, (s1, s2) -> s1.getScore() - s2.getScore());
        System.out.println("점수 오름차순: " + students);

        // 4. Comparator의 정적 메소드 활용 (Java 8+)
        students.sort(Comparator.comparing(Student::getName).reversed());
        System.out.println("이름 내림차순: " + students);

        // 5. 복합 정렬: 점수로 먼저, 같으면 이름으로
        students.sort(Comparator.comparing(Student::getScore)
                .thenComparing(Student::getName));
        System.out.println("점수 후 이름순: " + students);
    }
}
```

- compare()는 Comparator를 사용할 때만 호출됨
- return s1.getName().compareTo(s2.getName());
    - String.compareTo() → 두 문자열을 사전순으로 비교
    - s1 → 첫 번째 학생의 이름, s2 → 두 번째 학생의 이름을 비교

### **※ Comparable VS Comparator**

- Comparable : 클래스의 기본 정렬 기준 (하나만 가능)
- Comparator : 여러 정렬 기준 정의 가능 (유연성)
- 둘 다 있으면 Comparator가 우선순위를 가진다.

### 제네릭을 사용하는 주요 이유

1. 컴파일 타임에 타입 안정성을 보장
2. 형변환 불필요
3. 정해진 타입만 사용하도록 강제
4. 잘못된 타입 사용으로 인한 런타임 오류 방지

---

### 예외 처리가 필요한 이유

1. 프로그램의 안정성과 신뢰성 보장
    - 예외 처리를 통해 프로그램이 예상치 못한 상황에서도 중단되지 않고 계속 실행시킬 수 있다.
2. 오류의 조기 발견 및 대응
3. 사용자 경험 개선
4. 시스템 자원의 안전한 관리

### 프로그램 오류의 종류

**컴파일 에러**

- 컴파일시 발생하는 에러
- 문법 오류, 타입 불일치 등

**런타임 에러**

- 실행시 발생하는 에러
- 메모리 부족, 0으로 나누기 등

### Error와 Exception

**Error** : 수습할 수 없는 심각한 오류

**Exceprion**(예외) : 예외 처리를 통해 수습할 수 있는 덜 심각한 오류

### 예외 처리의 문법

예외 처리의 기본 ( try-catch )

예외 떠넘기기 ( throws ) → 09-03 회고록 참

**try-catch**

```java
public class Exception1 {
    public static void main(String[] args) {
        ExceptionObj1 exobj = new ExceptionObj1();
        int value = exobj.divide(10, 0);
        System.out.println(value);
    }
}

class ExceptionObj1 {
    public int divide(int i, int k) {
        int value = 0;
        try {
            value = i / k;
        } catch(ArithmeticException ex) {
            System.out.println("0으로 나눌 수 없습니다.");
        }
        return value;
    }
}
```

**Checked Exception** 

```java
import java.io.FileInputStream;
import java.io.IOException;

public class Exception4 {
    public static void main(String[] args) {
        // 컴파일 오류가 발생한다.
        // FileInputStream fis = new FileInputStream("Exception5.java");

        // 올바른 처리 방법 1: try-catch
        try {
            FileInputStream fis = new FileInputStream("Exception5.java");
        } catch(IOException e) {
            System.out.println("파일을 찾을 수 없습니다.");
        }

        // 올바른 처리 방법 2: throws (메소드에 선언)
    }
}
```

- 파일, DB 같이 외부 자원을 다룰 때 자주 발생

**다중 예외 처리 ( multi-catch )**

```java
public class Exception6 {
    public static void main(String[] args) {
        // {4,2} 로 바꿔서 실행해보고. int[] array = null로도 바꿔본다.
        int[] array = {4, 0};
        int[] value = null;

        try {
            value[0] = array[0] / array[1];
        } catch(ArrayIndexOutOfBoundsException aiob) { <- 발생
            System.out.println(aiob.toString());
        } catch(ArithmeticException ae) {
            System.out.println(ae.toString());
        } catch(NullPointerException npe) {
            System.out.println("null 참조 오류: " + npe.toString());
        } catch(Exception ex) {
            System.out.println("기타 예외: " + ex);
        }
    }
}
```

- 여러 예외를 처리하는 방법
- 위에서부터 차례대로 검사해서, 해당하는 예외 타입의 catch 블록 실행
- 여러 종류의 예외를 개별적으로 처리하기 위해 catch를 여러개 사용