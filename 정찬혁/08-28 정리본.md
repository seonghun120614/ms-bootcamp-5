# 08-28

### 컬션 프레임워크

- 컬렉션 프레임워크는 자바에서 데이터 집합을 효율적으로 처리할 수 있도록 설계된 표준화된 방법을 제공
- 컬렉션 프레임워크의 핵심은 **데이터를 저장, 검색, 조작, 통신**할 때 **일관된 접근 방식**을 제공하는 것이다.

### 자료구조의 필요성

1. **효율적인 데이터 관리**
- 컬렉션 프레임워크는 데이터를 체계적으로 관리할 수 있도록 돕습니다.
- 예를 들어, 리스트는 순서를 유지하는 반면, 세트는 중복을 허용하지 않습니다.

1. **성능 최적화** 
- 다양한 자료구조를 사용함으로써 특정 작업에 최적화된 성능을 얻을 수 있다.
- 예를 들어, 빠른 검색을 위해서는 해시맵을 사용할 수 있고, 요소의 순서를 유지해야 하는 경우에는 어레이리스트 또는 링크드리스트를 사용할 수 있다.

1. **재사용성 및 유지 보수** 
- 일관된 인터페이스를 제공함으로써 컬렉션 프레임워크는 코드의 재사용성을 높이고 유지 보수를 용이하게 한다.

1. **오류 방지**
- 일관된 인터페이스와 제네릭을 사용함으로써 타입 오류를 방지하고 안전한 코드 작성을 도울 수 있다.

### 컬렉션 프레임워크의 구조

Collection, Map 인터페이스, 그리고 이들을 구현하는 여러 클래스들로 구성된다.

![Java-Collection-Framework-Structure.png](image/Java-Collection-Framework-Structure.png)

1. **Collection 인터페이스**
    1. List
        - 순서가 있는 데이터의 집합
        - 중복 O
        - ArrayList, LinkedList와 같은 클래스가 이 인터페이스를 구현한다.
    2. Set
        - 순서를 유지하지 않는 데이터 집합
        - 중복 X
        - HashSet, TreeSet이 대표적
    3. Queue
        - FIFO(First In First Out)구조를 가진 컬렉션
        - LinkedList, PriorityQueue 등이 해당
        
2. **Map 인터페이스 (파이썬에서 딕셔너리 개념)**
    - 키와 값의 쌍으로 데이터를 저장
    - HashMap , TreeMap , LinkedHashMap 과 같은 구현 클래스를 포함

---

### Iterator

List 계열 클래스 

- ArrayList , LinkedList 등 List 인터페이스를 구현하는 모든 클래스들은 Iterator를 지원한다.
- 이를 통해 리스트 내의 요소들을 순차적으로 접근할 수 있다.

Set 계열 클래스

- HashSet , TreeSet 과 같은 Set 인터페이스를 구현하는 클래스들도 Iterator를 지원한다.
- Set은 순서가 없는 컬렉션이지만, Iterator를 사용하여 요소들을 순회할 수 있다.

Map 계열 클래스

- HashMap , TreeMap 과 같은 Map 인터페이스를 구현하는 클래스들은 keySet, entrySet, values 메소드를 통해 반환된 컬렉션을 Iterator를 사용하여 순회할 수 있다

### Iterator 예제 코드

```java
import java.util.ArrayList;
import java.util.Iterator;

public class IteratorExample {
    public static void main(String[] args) {
        // ArrayList 생성 및 요소 추가
        ArrayList<String> fruits = new ArrayList<>();
        fruits.add("사과");
        fruits.add("바나나");
        fruits.add("오렌지");
        fruits.add("포도");

        // Iterator를 사용하여 ArrayList 순회
        Iterator<String> iterator = fruits.iterator();
        while (iterator.hasNext()) { //Iterator 인터페이스
            String fruit = iterator.next();
            System.out.println(fruit);
        }
    }
}
```

hasNext → Iterator 인터페이스 -> 아직 꺼내지 않은 다음 요소가 있는지 확인 → 요소가 있으면 true 반환

iterator.next() → 그다음 요소를 반환하고, iterator의 위치를 다음 요소로 이동시킨다.

---

### 제네릭 <>

```java
ArrayList<String> sList = new ArrayList<>();

        sList.add("abc");
        // sList.add(11); --> 인트형을 넣을려고 하니까 오류
```

- <>안에 타입을 적어서 원하는 타입을 지정할 수 있게 해주는 문법
- Ex; 위에 코드에서는 제네릭을 이용하여 String만 들어갈 수 있게 설정

**제네릭을 사용하는 이유** 

- 제네릭을 안 쓰면 Object 타입으로 저장 → 꺼낼 때마다 (String)같은 형변환이 필요하다.
- 제네릭을 쓰면 꺼낼 때 자동으로 해준다. (형변환 필요 없음)
- 타입이 명확하니까 코드 읽고 쓰기가 쉬워짐 (가독성 향상)

결론 : <>사용 안 하고 무지성으로 아무 타입이나 넣으면 꺼낼 때마다 형변환해줘야함.

---

### List

**ArrayList**

- 내부적으로 동적 배열을 사용하여 요소를 저장
- 인덱스를 통한 빠른 임의 접근이 가능하며, 요소 추가 및 삭제 시 다른 요소들의 이동이 필요할 수 있다.

**LinkedList**

- 이중 연결 리스트를 사용하여 요소를 관리
- 요소의 추가와 삭제가 빠르지만, 임의 접근에는 상대적으로 시간이 더 걸린다.

**Vector**

- ArrayList와 유사, 스레드에 안전한 방식으로 구현되어 있다.
- 멀티스레드 환경에 적합, 성능이 다소 느림

**Stack**

- Vector를 상속받은 클래스로, 후입선출(LIFO) 방식의 데이터 처리에 사용

결론 : ArrayList, LinkedList 잘 알아두자 다른 건 필요할 때 구글링 

### List 예제코드

```java
import java.util.ArrayList;
import java.util.List;

public class ListExample {
    public static void main(String[] args) {
        // ArrayList 생성
        List<String> fruits = new ArrayList<>();

        // 요소 추가
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Cherry");

        // 요소 접근
        String firstFruit = fruits.get(0);
        System.out.println("첫번째 과일: " + firstFruit);

        // 요소 수정
        fruits.set(1, "Blueberry");

        // 요소 삭제
        fruits.remove("Cherry");

        // 리스트 출력
        System.out.println("업데이트된 과일 리스트: " + fruits);
    }
}
// 첫 번재 과일 : Apple
// 업데이트된 과일 리스트: [Apple, Blueberry]
```

---

### Set

**HashSet**

- 가장 널리 사용되는 Set 구현체, 내부적으로 HashMap을 사용하여 요소를 저장,
- 요소의 순서를 보장 X
- 빠른 검색 속도 제공

**LinkedHashSet**

- HashSet과 유사하지만, 요소들을 삽입된 순서대로 유지.
- LinkedList의 형태로 데이터를 저장하여 순서를 보존

**TreeSet** (필요할 때 찾아 쓰자)

- 요소들을 정렬된 순서대로 저장하고 검색, 삭제, 삽입 작업을 효율적으로 수행

### Set 예제 코드

```java
import java.util.HashSet;
import java.util.Set;

public class SetExample {
    public static void main(String[] args) {
        // HashSet 생성
        Set<String> fruitSet = new HashSet<>();

        // 요소 추가
        fruitSet.add("사과");
        fruitSet.add("바나나");
        fruitSet.add("키위");
        fruitSet.add("바나나"); // 중복 요소 추가 시도 (차피 안됨)

        // 요소 출력
        System.out.println("과일 집합: " + fruitSet);

        // 특정 요소 포함 여부 확인
        if (fruitSet.contains("키위")) {
            System.out.println("키위가 있습니다.");
        }

        // 요소 제거
        fruitSet.remove("바나나");
        System.out.println("바나나 제거 후: " + fruitSet);

        // 집합의 크기
        System.out.println("집합의 크기: " + fruitSet.size());
    }
}
/*
과일 집합: [사과, 바나나, 키위]
키위가 있습니다.
바나나 제거 후: [사과, 키위]
집합의 크기: 2
*/
```

contains → 특정 요소 찾기

---

### Map

**Map의 특징**

- **고유한 키** : Map 내의 각 키는 중복될 수 없습니다. 하나의 키는 오직 하나의 값을 가
리킬 수 있습니다.
- **값의 매핑** : 키를 사용하여 값을 저장하고, 나중에 같은 키로 해당 값을 검색할 수 있
다.
- **순서의 무관성** : 대부분의 Map 구현체에서는 요소들의 순서를 보장하지 않다.
즉, 요소들이 추가된 순서대로 저장되지 않을 수 있다.

**HashMap**

- 가장 일반적으로 사용되는 Map 구현체
- 해시 테이블을 사용하여 키와 값을 저장한다, 순서를 보장하지 않으며, null 키와 값이 허용된다.

**TreeMap**

- 레드-블랙 트리 기반의 Map 구현체
- 키에 따라 정렬된 순서로 키-값 쌍을 저장
- 키의 자연 순서에 따라 정렬되거나, 생성자에 제공된 Comparator에 의해 정렬된다.

**LinkedHashMap**

- HashMap과 유사하지만, 요소들이 추가된 순서 또는 접근 순서를 유지한다
- 이러한 특성은 순서가 중요한 시나리오에서 유용

**Hashtable**

- 잘 사용 안 한다. 필요할 때 구글링해서 쓰자

### Map 예제 코드

```java
import java.util.HashMap;
import java.util.Map;

public class PhoneBookExample {
    public static void main(String[] args) {
        // HashMap 생성
        Map<String, String> phoneBook = new HashMap<>();

        // 전화번호 추가
        phoneBook.put("김철수", "010-1234-5678");
        phoneBook.put("박영희", "010-8765-4321");
        phoneBook.put("이민지", "010-5566-7788");

        // 특정 키를 이용해 전화번호 검색
        String minjiNumber = phoneBook.get("이민지");
        System.out.println("이민지의 전화번호: " + minjiNumber);

        // 전체 전화번호 목록 출력
        System.out.println("전체 전화번호 목록:");
        for (Map.Entry<String, String> entry : phoneBook.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}
/*
이민지의 전화번호: 010-5566-7788
전체 전화번호 목록:
박영희: 010-8765-4321
이민지: 010-5566-7788
김철수: 010-1234-5678
*/
```

- get(”이민지”) → Key가 “이민지”인 Value를 가져오는 메소드