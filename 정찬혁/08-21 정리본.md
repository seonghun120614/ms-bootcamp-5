# 08-21

### 가변 길이 매개변수

- 타입… 변수명

```java
public class VarArgsExample {

    // 가변인자 메소드
    public static int add(int... numbers) { //가변인자라고 부른다.
        int sum = 0;
        for (int n : numbers) {
            sum += n;
        }
        return sum;
    }

    public static void main(String[] args) {
        System.out.println(add());           // 0개 → 0 출력
        System.out.println(add(5));          // 1개 → 5 출력
        System.out.println(add(1, 2, 3));    // 3개 → 6 출력
        System.out.println(add(10, 20, 30, 40)); // 4개 → 100 출력
    }
}

```

- int… numbers → 0개 이상의 int 값을 받을 수 있다는 의미
- 내부적으로 int[] numbers 배열로 처리됨
- 즉, 호출할 때 몇 개를 넣든 다 받을 수 있음

어떻게 가능할까? 

- 컴파일에서 내부적으로 배열을 리

---

### 필드

- 클래스가 가지는 속성

필드 선언문

[접근 제한자] [static] [final] 타입 필드명 [= 초기값];

1. **접근 제한자**
    - public → 어디서든 접근 가능
    - protected → 같은 패키지와, 패키지는 달라도 상속관계에 있다면 공개
    - private → 비공개 내 클래스 내에서만 사용 가능, 상속해도 X
    - 생략 → 같은 패키지에서만 공개

```java
Person p = new Person();  // new Person() → Person 클래스의 객체 생성
```

인스턴스화 - 클래스(설계도를 이용해서)를 객체(물건)를 만들어 내는 행위

- new → 인스턴스화할 수 있는 예약어
- 즉, new가 객체를 생성하는 예약
- 객체 생성 = 인스턴스

필드 예제

```java
// 인스턴스 필드
String name;
int age;
String address = "서울시";

//클래스 필드 (static)
static int count = 0;

//상수 (static final -> 상수로서 처음 지정하면 끝)
static final int MAX_AGE = 150;
```

---

### 객체

→  클래스명 변수명 = new 클래스명();

```java
new Pen()
```

- 참조 변수가 없으므로, 생성된 객체를 나중에 다시 사용할 방법이 없다.

```java
Pen myPen = new Pen();
```

- myPen → Pen 객체를 가리키는 **참조 변수**
- myPen을 통해 객체의 필드와 메소드에 접근 가능

---

### 메소드

```java
[접근제한자] [static] 반환타입 메소드명(매개변수){
	// 메소드 본문
	return 반환값;
}
```

```java
public class Calculator {

    // 1. 매개변수 X, 반환값 X
    public void printInfo() {
        System.out.println("계산기 v1.0");
    }

    // 2. 매개변수 O, 반환값 X
    public void printNumber(int num) {
        System.out.println("숫자: " + num);
    }

    // 3. 매개변수 X, 반환값 O
    public String getVersion() {
        return "v1.0";
    }

    // 4. 매개변수 O, 반환값 O
    public int add(int a, int b) {
        return a + b;
    }

    // 5. 여러 매개변수
    public double calculate(double x, double y, String operator) {
        switch(operator) {
            case "+": return x + y;
            case "-": return x - y;
            case "*": return x * y;
            case "/": return x / y;
            default: return 0;
        }
    }
}
```

---

### 오버로딩

같은 메소드 이름을 사용

but : 매개변수의 개수, 타입, 순서 중 하나라도 다르게 해야 한다.

---

### 6. 생성자

- 클래스 이름과 동일한 이름을 가짐
- 변환 타입이 없음(void도 쓰지 않음)
- 리턴 타입이 없고, return으로 값을 반환할 수 없다.

```java
Pen(String c, int s){
	color = c;
	size = s;
	// return redPen();   X 생성자에서는 return 값을 쓸 수 없음
}
```

### 생성자 예제

```java
package day04;

public class Exam {

    static class Pen {  // static으로 만들면 외부 객체 필요 없음
        String color;
        int size;

        Pen(String c, int s) {
            color = c;
            size = s;
        }

        void write(String text) {
            System.out.println(color + " 펜(" + size + "mm)으로 " + text + "를 씁니다.");
        }
    }

    public static void main(String[] args) {
        Pen redPen = new Pen("빨간색", 5);
        Pen bluePen = new Pen("파란색", 3);

        redPen.write("안녕하세요");
        bluePen.write("반갑습니다");
    }
}
```

출력 결과

빨간색 펜으로 안녕하세요를 씁니다.

파란색 펜으로 반갑습니다를 씁니다.

Pen redPen = new Pen("빨간색", 5);

rdePen이라는 변수를 Pen에서 사용 가능하도록 지정

Pen(”빨간색”, 5);에서 나온 값을 redPen에 저장

redPen에는 color = 빨간색, size = 5라는 값이 들어있게 된다.

---

### static

```java
package day04;

public class PersonExam {
    public static void main(String[] args) {
        Person.count++;
        System.out.println(Person.MAX_AGE);
        System.out.println(Person.count);

    }
}
```

- new로 객체를 만들지 않더라도 static을 사용하면 괜찮다
- static이 붙으면 다른 파일이더라도 Person이라는 클래스를 찾아간다.
    - 다른 패키지에 있으면 import가 필요하다.